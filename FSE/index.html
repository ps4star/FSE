<!DOCTYPE HTML>
<html>
    <head>
        <title>FSE v1.0</title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="./tables.js" type="text/javascript"></script>
		<script src="./scripts.js" type="text/javascript"></script>
    </head>
    <body style="font-family: 'Trebuchet MS'; overflow: hidden;">
        <p style="margin-top: 19px;">Starting Offset:</p>
        <input id="offset" type="text" style="position: absolute; top: 38px;" value="0x197D000"></input>
        <select style="position: absolute; top: 1px;">
            <option id="rse" value="1" selected>Ruby/Sapphire/Emerald</option>
            <option id="frlg" value="2">FireRed/LeafGreen</option>
        </select>
        <div style="position: absolute; left: 15%; top: 6.1%;">
        <label for="ts">Editor Theme:</label>
        <select name="ts" id="theme" style="position: relative;" onclick="changeMode();">

        	<option>ambiance</option>
        	<option>chaos</option>
        	<option>chrome</option>
        	<option>clouds</option>
        	<option>clouds_midnight</option>
        	<option>cobalt</option>
        	<option>crimson_editor</option>
        	<option>dawn</option>
        	<option>dracula</option>
        	<option>dreamweaver</option>
        	<option>eclipse</option>
        	<option>github</option>
        	<option>gob</option>
        	<option>gruvbox</option>
        	<option>idle_fingers</option>
        	<option>iplastic</option>
        	<option>katzenmilch</option>
        	<option>kr_theme</option>
        	<option>kuroir</option>
        	<option>merbivore</option>
        	<option>merbivore_soft</option>
        	<option>mono_industrial</option>
        	<option>monokai</option>
        	<option>nord_dark</option>
        	<option>pastel_on_dark</option>
        	<option>solarized_dark</option>
        	<option>solarized_light</option>
        	<option>sqlserver</option>
        	<option>terminal</option>
        	<option>textmate</option>
        	<option>tomorrow</option>
        	<option>tomorrow_night</option>
        	<option>tomorrow_night_blue</option>
        	<option>tomorrow_night_bright</option>
        	<option>tomorrow_night_eighties</option>
        	<option selected>twilight</option>
        	<option>vibrant_ink</option>
        	<option>xcode</option>


        </select>
    	</div>
        <br>
        <br>
        <button id="convert_button" onclick="convert();" style="position: absolute; top: 75px; left: 11.1%;">Convert! (Ctrl+Q)</button>
        <button id="help-button" onclick="launchHelp();" style="position: absolute; top: 75px;">Documentation/Help</button>
        <br>
        <br>
        <p style="position: absolute; left: 10px; top: 13.65%;">FSE code (input)</p>
        <p style="position: absolute; left: 632px; top: 13.65%;">XSE code (output; automatically copied to clipboard)</p>
        <div id="in" style="position: absolute; top: 19%; right: 0%; left: 9px; bottom: 0; margin-right: 55%;"></div>
        <textarea id="out" cols="85" rows="33" readonly style="position: absolute; left: 46%; top: 18.95%; background-color: black; color: white; font-family: 'Trebuchet MS'; overflow-y: scroll;"></textarea>
        <br>
        <p id = "status" style="position: absolute; top: -2.5%; left: 15%;">Welcome to FSE. This message will tell you whether or not a conversion was successful.</p>
        <script src="./ace/ace.js" type="text/javascript" charset="utf-8"></script>
        <script defer>



var keysDown = [];

document.addEventListener("keyup", function(e) {

    delete keysDown[keysDown.indexOf(e.key)];

});

document.addEventListener("keydown", function(e) {

    keysDown.push(e.key);

    if (keysDown.indexOf("Control") > -1 && keysDown.indexOf("q") > -1) {
        convert();
		keysDown = [];
    }

});

function launchHelp() {

	window.open("https://github.com/ps4star/FSE/blob/master/ref.md");

}



var themeSel = document.getElementById("theme");

//Code editor stuff
var FSEeditor = ace.edit("in", {wrap: true});
FSEeditor.setTheme("ace/theme/xcode");
FSEeditor.session.setMode("ace/mode/assembly_x86");

if (localStorage["selection"] == "undefined") {
	localStorage["selection"] = "twilight";
}

let ops = [];
for (var i = 0; i < themeSel.options.length; i++) {
	ops.push(themeSel.options[i].text);
}
themeSel.selectedIndex = ops.indexOf(localStorage["selection"]);
console.log(themeSel.selectedIndex);

function changeMode() {
	localStorage["selection"] = themeSel.options[themeSel.selectedIndex].text;
	FSEeditor.setTheme("ace/theme/"+localStorage["selection"]);
}
changeMode();

document.getElementById('in').style.fontSize='20px';

FSEeditor.focus();

var noliNewLineAre = false;


function determineType(data) {
    if (data.indexOf("#raw") > -1) {
        return "#raw";
    } else if (data.charAt(0)+data.charAt(1) == "= ") {
        return "text";
    }
}


function calcBytes(dataType, data) {
    if (dataType == "#raw") {
        return data.split("\n").length;
    } else if (dataType == "text") {
        console.log(data);
        return data.length-2;
    }
}





var currOff = 0;

function getOff() {
	let ret = "@off"+currOff.toString();
	return ret;
}

function nextOff() {
	currOff++;
}


String.prototype.addOrg = function(data) {
    var toReturn = "#org "+getOff()+"\n"+data;
    nextOff();
    goff = parseInt(goff, 16);
    goff += calcBytes(determineType(data), data);
    goff++; //Adds the extra byte to avoid overwriting terminators
    if (determineType(data) == "text") {
        goff++; //padding for strings. may not be necessary.
    }
    goff = "0x"+goff.toString(16).toUpperCase();
    return toReturn+"\n\n";
}


var cSpeed = "normal";

function isHex(n) {
	return (n.charAt(0)+n.charAt(1) == "0x");
}

function parseMoves(input) {

    if (whichGame == "rse") {
        var currentTable = rseMoveTable;
    } else {
        var currentTable = frlgmovetable;
    }

    var res = "";

    for(var i = 0; i < input.length; i++) {
		input[i] = input[i].replace("u", "up").replace("d", "down").replace("l", "left").replace("r", "right");
		if (input[i].charAt(0) == ";") {
			break;
		}
        if (["up", "down", "left", "right"].indexOf(input[i]) > -1) {
            input[i] += cSpeed;
            console.log(input[i]);
        }
		if (isHex(input[i])) {
			res += "#raw "+input[i]+"\n";
		} else {
			res += "#raw "+currentTable[input[i]]+"\n";
		}
    }
    return res+"#raw 0xFE";

}

function pokeToID(poke) {

    return pokemontable[poke.toLowerCase()];

}

function itemToID(item) {

    return itemstable[item.toLowerCase()];

}


var success = true;


function toXSEhex(hexnum) {
    return "0x"+hexnum.toString(16).toUpperCase();
}

var constTable = {};

function deref(n) {

	if (Object.keys(constTable).indexOf(n) > -1) {
		return constTable[n].split(" ");
	} else {
		return n;
	}
	
}

function derefAllFromIndex(arr, index) {

	for (let v = index; v < arr.length; v++) {
	
		arr[v] = deref(arr[v]);
	
	}
	
	return arr.flat();

}

function removeComments(arr) {

	let res = [];

	for (let e = 0; e < arr.length; e++) {
	
		if (arr[e].charAt(0) == ";") {
			break;
		}
		
		res.push(arr[e]);
	
	}
	
	return res;

}

var cLab = "@start";
var endCalled = false;
var activeLabel = false;

var textBreakLimit = 27;

var pageonbreak = false;

var autobreak = true;

function resetAll() {
	currOff = 0;
	constTable = {};
	cLab = "@start";
	
	lockReleaseText = "";
	
	endCalled = false;
	activeLabel = false;
	
	pageonbreak = false;
	textBreakLimit = 27;
	
	autobreak = true;
}



function doLines(n) {

	if (!autobreak) {
		return n;
	}

	var chars = n.split("");
	var charID = 0;
	var hasBroken = false;
	var res = "";
	var doNotAddChar = false;
	
	var breaks = 0;
	
	for (let iter = 0; iter < chars.length; iter++) {
	
		if (charID >= textBreakLimit && !hasBroken && chars[iter] == " ") {
			res += "\\n";
			hasBroken = true;
			charID = -1;
			doNotAddChar = true;
			breaks++;
		} else if (charID >= textBreakLimit && chars[iter] == " ") {
			if (pageonbreak) {
				if (breaks % 2 != 0) {
					res += "\\p";
				} else {
					res += "\\n";
				}
			} else {
				res += "\\l";
			}
			charID = -1;
			doNotAddChar = true;
			breaks++;
		}
		
		if (!doNotAddChar) {
		
			res += chars[iter];
			
			if (["\n", "\l", "\p"].indexOf(chars[iter]) > -1) {
				charID = -1;
				breaks++;
			}
			
		} else {
		
			doNotAddChar = false;
		
		}
	
		charID++;
	
	}
	
	return res;

}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function repArgs(data, args, arg) {

	var res = data;

	for (let m = 0; m < args; m++) {
	
		res = res.replace("%ARG_"+(m+1), arg[m+2]);
		
	}
	
	return res.replace("&sp", " ").split("\n");

}

function getHighestArgFromTemplate(template) {

	var lns = template.split('\n');
	var cHighest = 0;
	
	for (let i = 0; i < lns.length; i++) {
	
		while (lns[i].includes("%ARG_")) {
			let argInt = lns[i].substring(lns[i].indexOf("%ARG_")+5, lns[i].length).split(" ")[0];
			if (parseInt(argInt) > cHighest) {
				cHighest = parseInt(argInt);
			}
			
			lns[i] = lns[i].replace("%ARG_"+parseInt(argInt).toString(), "");
		}
	
	}
	
	return cHighest;

}

getHighestArgFromTemplate(`
msg %ARG_1 0x4
msg %ARG_2 0x4
msg %ARG_3 0x4
`); //holy shit it actually worked first try, no debugging, wtf???

var loadedJson = {};

function getXSE(text) {
    var lines = (text+"\n").split(/\n/);
	var actualLength = lines.length;
    var header1 = "#dynamic "+goff;
	var scriptText = "\n";
	var header2 = "\n#org @start\n\n";
    var body = "";
    var footer = "";
	
	var endsNeeded = 1;
	
	var cEndingText = "\n\nend";

	//console.log(goff)
    for(var i = 0; i < lines.length; i++) {
        var cline = lines[i];

        if (cline.charAt(0) != ";") {
        var arg = cline.split(" ");
		
		arg = removeComments(arg);

        switch(arg[0].toLowerCase()) {
            case "applymovement":
            case "move":
			case "applymovementnowait":
            case "movenowait":
				arg = derefAllFromIndex(arg, 1);
				console.log(arg);
                body += "applymovement "+arg[1]+" "+getOff();

                if (!(arg[0] == "movenowait")) {
                    body += "\nwaitmovement 0x0";
                }

                footer += footer.addOrg(parseMoves(arg.slice(2)));
                break;
			case "func":
			case "fcall":
				arg = derefAllFromIndex(arg, 1);
				
				arg[1] = arg[1].toLowerCase();
				
				if (Object.keys(allScripts).indexOf(arg[1]) == -1) {
					success = false;
					alert("Function "+arg[1]+" not defined. Edit scripts.js to create a definition.");
					return;
				}
				
				let thisHighestArg = getHighestArgFromTemplate(allScripts[arg[1]]);
				
				if (Object.keys(allScripts).indexOf(arg[1]) == -1) {
				
					console.log(arg);
				
					success = false;
					alert("Function specified on line "+(actualLength)+" does not exist. Please create a definition in scripts.js.");
					return;
				
				}
				
				if (arg.length-2 != thisHighestArg) {
					success = false;
					alert("Mismatch between specified external function arguments and actual arguments provided.");
				}
				
				lines.splice(i+1, 0, repArgs(allScripts[arg[1]], thisHighestArg, arg));
				lines = lines.flat();
				console.log(lines);
				
				break;
			case "setbreaklimit":
			case "breaklimit":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				textBreakLimit = parseInt(arg[1]);
				
				break;
			case "pageonbreak":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				pageonbreak = ( arg[1] == 'true' );
				
				break;
			case "if":
				body += "if "+arg.slice(1).join(" ");
				break;
			case "goto":
				arg = derefAllFromIndex(arg, 1);
				
				body += "goto "+arg.slice(1).join(" ");
				
				break;
			case "l":
			case "lock":
				body += "lock";
				break;
			case "lf":
			case "lockface":
			case "lockfaceplayer":
				body += "lock\nfaceplayer";
				break;
			case "face":
			case "faceplayer":
				body += "faceplayer";
				break;
			case "rel":
			case "release":
				if (cLab != "@start" && !activeLabel) {
					success = false;
					alert("Release statements must either be in @start or another label. This release is not in any label. Exception on line "+(actualLength-1)+".");
				}
				body += "release";
				break;
			case "lbl":
			case "org":
			case "label":
				activeLabel = true;
				endsNeeded++;
				if (cLab == "@start" && endsNeeded == 2) {
					body += "\nend\n";
				}
				cLab = arg[1];
				if (arg[1].charAt(0) != "@") {
					success = false;
					alert("Labels must start with @. Error on line "+(i+1)+".");
				}
				body += "\n#org "+arg[1]+"\n";
				break;
			case "ret":
			case "return":
				activeLabel = false;
				endsNeeded--;
				endCalled = true;
				body += "\nreturn\n";
				break;
			case "end":
				activeLabel = false;
				endCalled = true;
				body += "\nend";
				endsNeeded--;
				break;
			case "const":
			case "define":
				if (arg.length < 3) {
					success = false;
					alert("Consts require a name and value (2 params). Params given: "+(arg.length-1)+".");
				}
				if (["@", "%", "!", "#", "$"].indexOf(arg[1].charAt(0)) == -1 || Object.keys(constTable).indexOf(arg[1]) > -1) {
					success = false;
					alert("Const on line "+(i+1)+" either does not start with const identifier (%) or has already been defined.");
				}
				constTable[arg[1]] = arg.slice(2).join(" ");
				noliNewLineAre = true;
				break;
			case "setflag":
			case "sf":
				arg = derefAllFromIndex(arg, 1);
				
				body += "setflag "+arg[1];
				
				break;
			case "clearflag":
			case "cf":
				arg = derefAllFromIndex(arg, 1);
				
				body += "clearflag "+arg[1];				
				
				break;
            case "warp":
				arg = derefAllFromIndex(arg, 1);
                body += "warp 0x"+parseInt(arg[1], 16)+" 0x"+parseInt(arg[2], 16)+" 0x"+parseInt(arg[3], 16)+" 0x0 0x0";
                break;
			case "setautobreak":
			case "autobreak":
				arg = derefAllFromIndex(arg, 1);
				
				autobreak = ( arg[1] == 'true' );
				
				break;
            case "setspeed":
			case "setmovespeed":
				arg = derefAllFromIndex(arg, 1);
                if (arg[1]+arg[2] == "veryslow" || arg[1] == "veryslow" || arg[1] == "vslow") {
                    if (whichGame == "rse") {
                        alert("The 'very slow' speed did not exist in R/S/E. Please change the game to FR/LG if you're working with that game, or adjust the speed to 'slow', 'normal', 'fast', 'faster', or 'fastest' if you're working with R/S/E.");
                        success = false;
                    } else {
                        cSpeed = "veryslow";
                    }
                } else {
					if (arg[1]+arg[2] == "veryslow") {
						cSpeed = "veryslow";
					} else {
						cSpeed = arg[1];
					}
                }
                noliNewLineAre = true;
                break;
            case "msgbox":
            case "msg":
				if (arg.length < 3) {
					success = false;
					alert("msgbox requires 2 arguments, "+(arg.length-1)+" provided.");
				}
				arg = derefAllFromIndex(arg, 1);
				if (!(isHex(arg[arg.length-1]))) {
					success = false;
					alert("last argument of msgbox is not a msgbox type (hex int). This error could also be caused by failing to escape \n in an externally-called msgbox. Use \\n for external strings, not \n.");
				}
            	let txtOff = getOff();
                body += "msgbox "+txtOff+" "+arg.slice(-1)[0];
                footer += footer.addOrg("= "+doLines(arg.slice(1, -1).join(" "))); //Adds our text data.
                break;
			case "giveitem":
			case "item":
				arg = derefAllFromIndex(arg, 1);
				
				break;
            case "givepokemon":
            case "pokemon":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				arg[3] = arg[3].toLowerCase().replace("-", "").replace("_", "");
                console.log("arg 1 init");
                if (!arg[1].includes("0x")) { //Checks if already in hex number format.
					var oArg = arg[1];
                    arg[1] = pokeToID(arg[1].toLowerCase()); //If not, set it to the decimal pokemon ID.
                }
                if (!arg[1].includes("0x")) { //It can now be either a hex pokemon ID or decimal pokemon ID.
                    arg[1] = toXSEhex(parseInt(arg[1])); //So if it's still not a hex number, convert it from dec number to hex number.
                }
                //So now we have a hexidecimal pokemon identifier that meets XSE's standards.
                if (!arg[2].includes("0x")) { //Checks if the level is in hex already.
                    arg[2] = toXSEhex(parseInt(arg[2])); //If not, convert it to hex
                }
                //So now we have our pokemon identifier and our hex level value.
                arg[3] = arg.slice(3).join(" ");
                if (Object.keys(itemstable).indexOf(arg[3]) > -1) { //Checks if the held item is in hex already.
                    arg[3] = itemToID(arg[3].toLowerCase()); //If not, set it to the item ID from the item name.
                }
                if (!arg[3].includes("0x")) { //Checks if it's now not a hex number.
                    arg[3] = toXSEhex(parseInt(arg[3])); //If not, make it one.
                }
                //So now we have our pokemon ID in hex, a level in hex, and an item ID in hex.
                //But first we need to set up the 6+ pokemon check.
                body += "givepokemon "+arg[1]+" "+arg[2]+" "+arg[3]+" 0x0 0x0 0x0";

                break;
			case "":
				noliNewLineAre = true;
            default:
				arg = derefAllFromIndex(arg, 1);
                body += arg.join(" ");
                console.log("DEFAULT HERE");
                break;
        }
        
        if (!noliNewLineAre) {
            body += "\n";
        }
        noliNewLineAre = false;

        }

    }
	
	if (activeLabel) {
		success = false;
		alert("Label not closed. Use 'end' to close a label.");
	}
	
	if (!endCalled) {
		body += "\nend\n";
	}

    return header1+scriptText+header2+body+"\n"+footer+"\n\n";
}










function calcProgramBytes(text) {

    var lines = (text+"\n").split(/\n/);
    var bytesToOffset = 0;

    for(var i = 0; i < lines.length; i++) {
		var cline = lines[i];
        if (cline.charAt(0) != ";") {
        var arg = cline.split(" ");

        switch(arg[0].toLowerCase()) {
            case "applymovement":
            case "movement":
            case "mvmt":
            case "move":
            case "movenowait":
            case "movenowaitmovement":
            case "moven":
            case "moveno":
            case "movewait":
            case "movewithwait":
            case "movewithawait":
            case "movewithwaitmovement":
            case "movewithawaitmovement":
                bytesToOffset += arg.length;
                break;
            case "wrp":
            case "warp":
                bytesToOffset += 6;
                break;
            case "msgbox":
            case "msg":
            case "text":
            case "txt":
            case "filltext":
            case "domsgbox":
            case "message":
            case "messagebox":
                bytesToOffset += arg.slice(1).join(" ").length;
                break;
            case "givepokemon":
            case "givepoke":
            case "gp":
            case "addpokemon":
            case "pokemongive":
            case "poke":
            case "pokemon":
                if (text.includes("autoobtain false")) {
                    bytesToOffset += arg.length;
                }
                bytesToOffset += arg.length;
                break;
            default:
                bytesToOffset += arg.length+2;
                break;
        }
        }

    }

	return bytesToOffset;

}










var goff = document.getElementById("offset").value;
var whichGame = "rse";

var inbutton = document.getElementById("in");

if (localStorage["inputdata"] != "undefined" && localStorage["inputdata"] != undefined && localStorage["inputdata"] != null) {
    FSEeditor.setValue(localStorage["inputdata"], 0);
}




function convert() {
	resetAll();

    var inbutton = document.getElementById("in");
    var outbutton = document.getElementById("out");

    var rse = document.getElementById("rse").selected;
    var frlg = document.getElementById("frlg").selected;

    goff = document.getElementById("offset").value;
    var stat = document.getElementById("status");

    if (rse) {
        whichGame = "rse";
    } else {
        whichGame = "frlg";
    }

    var intext = FSEeditor.getValue();
    localStorage["inputdata"] = FSEeditor.getValue();

    var res = getXSE(intext);

    if (success) {
        outbutton.innerHTML = res;

        outbutton.select();
        document.execCommand("copy");
        window.getSelection().removeAllRanges();
		
		FSEeditor.focus();
        
        stat.innerHTML = "Conversion successful. Output data copied to clipboard.";
    } else {
        stat.innerHTML = "Conversion unsuccessful. An alert box should have explained the error.";
        success = true;
    }
	
	outbutton.scrollTop = 0;

}






















        </script>
    </body>
</html>
