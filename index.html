<!DOCTYPE HTML>
<html>
    <head>
        <title>FSE v1.0</title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="./tables.js" type="text/javascript"></script>
		<script src="./scripts.js" type="text/javascript"></script>
    </head>
    <body style="font-family: 'Trebuchet MS'; overflow: hidden;">
        <p style="margin-top: 19px;">Starting Offset:</p>
        <input id="offset" type="text" style="position: absolute; top: 38px;" value="0x197D000"></input>
        <select style="position: absolute; top: 1px;">
            <option id="rse" value="1" selected>Ruby/Sapphire/Emerald</option>
            <option id="frlg" value="2">FireRed/LeafGreen</option>
        </select>
        <div style="position: absolute; left: 15%; top: 6.1%;">
        <label for="ts">Editor Theme:</label>
        <select name="ts" id="theme" style="position: relative;" onclick="changeMode();">

        	<option>ambiance</option>
        	<option>chaos</option>
        	<option>chrome</option>
        	<option>clouds</option>
        	<option>clouds_midnight</option>
        	<option>cobalt</option>
        	<option>crimson_editor</option>
        	<option>dawn</option>
        	<option>dracula</option>
        	<option>dreamweaver</option>
        	<option>eclipse</option>
        	<option>github</option>
        	<option>gob</option>
        	<option>gruvbox</option>
        	<option>idle_fingers</option>
        	<option>iplastic</option>
        	<option>katzenmilch</option>
        	<option>kr_theme</option>
        	<option>kuroir</option>
        	<option>merbivore</option>
        	<option>merbivore_soft</option>
        	<option>mono_industrial</option>
        	<option>monokai</option>
        	<option>nord_dark</option>
        	<option>pastel_on_dark</option>
        	<option>solarized_dark</option>
        	<option>solarized_light</option>
        	<option>sqlserver</option>
        	<option>terminal</option>
        	<option>textmate</option>
        	<option>tomorrow</option>
        	<option>tomorrow_night</option>
        	<option>tomorrow_night_blue</option>
        	<option>tomorrow_night_bright</option>
        	<option>tomorrow_night_eighties</option>
        	<option selected>twilight</option>
        	<option>vibrant_ink</option>
        	<option>xcode</option>


        </select>
    	</div>
        <br>
        <br>
        <button id="convert_button" onclick="convert();" style="position: absolute; top: 75px; left: 11.1%;">Convert! (Ctrl+Q)</button>
        <button id="help-button" onclick="launchHelp();" style="position: absolute; top: 75px;">Documentation/Help</button>
        <br>
        <br>
        <p style="position: absolute; left: 10px; top: 13.65%;">FSE code (input)</p>
        <p style="position: absolute; left: 632px; top: 13.65%;">XSE code (output; automatically copied to clipboard)</p>
        <div id="in" style="position: absolute; top: 19%; right: 0%; left: 9px; bottom: 0; margin-right: 55%;"></div>
        <textarea id="out" cols="85" rows="33" readonly style="position: absolute; left: 46%; top: 18.95%; background-color: black; color: white; font-family: 'Trebuchet MS'; overflow-y: scroll;"></textarea>
        <br>
        <p id = "status" style="position: absolute; top: -2.5%; left: 15%;">Welcome to FSE. This message will tell you whether or not a conversion was successful.</p>
        <script src="./ace/ace.js" type="text/javascript" charset="utf-8"></script>
        <script defer>


String.prototype.replaceAt = function(index, replacement) {
    return this.substr(0, index+1) + replacement + this.substr(index + replacement.length);
}

var keysDown = [];

document.addEventListener("keyup", function(e) {

    delete keysDown[keysDown.indexOf(e.key)];

});

document.addEventListener("keydown", function(e) {

    keysDown.push(e.key);

    if (keysDown.indexOf("Control") > -1 && keysDown.indexOf("q") > -1) {
        convert();
		keysDown = [];
    }

});

function launchHelp() {

	window.open("https://github.com/ps4star/FSE/blob/master/ref.md");

}



var themeSel = document.getElementById("theme");

//Code editor stuff
var FSEeditor = ace.edit("in", {wrap: true});
FSEeditor.setTheme("ace/theme/xcode");
FSEeditor.session.setMode("ace/mode/assembly_x86");

if (localStorage["selection"] == "undefined") {
	localStorage["selection"] = "twilight";
}

let ops = [];
for (var i = 0; i < themeSel.options.length; i++) {
	ops.push(themeSel.options[i].text);
}
themeSel.selectedIndex = ops.indexOf(localStorage["selection"]);

function changeMode() {
	localStorage["selection"] = themeSel.options[themeSel.selectedIndex].text;
	FSEeditor.setTheme("ace/theme/"+localStorage["selection"]);
}
changeMode();

document.getElementById('in').style.fontSize='20px';

FSEeditor.focus();

var noliNewLineAre = false;


function determineType(data) {
    if (data.indexOf("#raw") > -1) {
        return "#raw";
    } else if (data.charAt(0)+data.charAt(1) == "= ") {
        return "text";
    }
}


function calcBytes(dataType, data) {
    if (dataType == "#raw") {
        return data.split("\n").length;
    } else if (dataType == "text") {
        return data.length-2;
    }
}





var currOff = 0;

function getOff() {
	let ret = "@"+autolabelname+currOff.toString();
	return ret;
}

function nextOff() {
	currOff++;
}


String.prototype.addOrg = function(data) {
    var toReturn = "#org "+getOff()+"\n"+data;
    nextOff();
    goff = parseInt(goff, 16);
    goff += calcBytes(determineType(data), data);
    goff++; //Adds the extra byte to avoid overwriting terminators
    if (determineType(data) == "text") {
        goff++; //padding for strings. may not be necessary.
    }
    goff = "0x"+goff.toString(16).toUpperCase();
    return toReturn+"\n\n";
}


var cSpeed = "normal";

function isHex(n) {
	return (n.charAt(0)+n.charAt(1) == "0x");
}

function parseMoves(input) {

    if (whichGame == "rse") {
        var currentTable = rseMoveTable;
    } else {
        var currentTable = frlgmovetable;
    }

    var res = "";

    for(var i = 0; i < input.length; i++) {
		input[i] = input[i].replace("u", "up").replace("d", "down").replace("l", "left").replace("r", "right");
		if (input[i].charAt(0) == ";") {
			break;
		}
        if (["up", "down", "left", "right"].indexOf(input[i]) > -1) {
            input[i] += cSpeed;
        }
		if (isHex(input[i])) {
			res += "#raw "+input[i]+"\n";
		} else {
			res += "#raw "+currentTable[input[i]]+"\n";
		}
    }
    return res+"#raw 0xFE";

}

function pokeToID(poke) {

    return pokemontable[poke.toLowerCase()];

}

function itemToID(item) {

    return itemstable[item.toLowerCase()];

}

function attackToID(attack) {

	return attacktable[attack.toLowerCase()];
	
}


var success = true;


function toXSEhex(hexnum) {
    return "0x"+hexnum.toString(16).toUpperCase();
}

var constTable = {};

function deref(n) {

	if (Object.keys(constTable).indexOf(n) > -1) {
		return constTable[n];
	} else {
		return n;
	}
	
}

function derefAllFromIndex(arr, index) {

	for (let v = index; v < arr.length; v++) {
	
		arr[v] = deref(arr[v]).split("&sp");
	
	}
	
	return arr.flat();

}

function derefAllFromIndexFcall(arr, index) {

	for (let v = index; v < arr.length; v++) {
	
		arr[v] = deref(arr[v]);
		
		console.log(arr[v]);
	
	}
	
	return arr.flat();

}

function removeComments(arr) {

	let res = [];

	for (let e = 0; e < arr.length; e++) {
	
		if (arr[e].charAt(0) == ";") {
			break;
		}
		
		res.push(arr[e]);
	
	}
	
	return res;

}

var cLab = "@start";
var endCalled = false;
var activeLabel = false;

var textBreakLimit = 30;
var originalTextBreakLimit = textBreakLimit;

var pageonbreak = false;

var autobreak = true;

var autolabelname = "offset";
var originalautolabelname = autolabelname;

var autosav = true;

function resetAll() {
	currOff = 0;
	constTable = {};
	cLab = "@start";
	
	lockReleaseText = "";
	
	endCalled = false;
	activeLabel = false;
	
	pageonbreak = false;
	textBreakLimit = originalTextBreakLimit;
	
	autobreak = true;
	
	autolabelname = originalautolabelname;
	
	autosav = true;
}



function doLines(n) {

	if (!autobreak) {
		return n;
	}

	var chars = n.split("");
	var charID = 0;
	var hasBroken = false;
	var res = "";
	var doNotAddChar = false;
	
	var lastSpace = 0;
	
	var breaks = 0;
	
	let kek = "meme meme2";
	
	for (let iter = 0; iter < chars.length; iter++) {
	
		if (chars[iter] == " ") {
			lastSpace = iter+breaks;
		}
	
		if (charID >= textBreakLimit && (!hasBroken && chars[iter] == " ")) {
			res = res.substring(0, lastSpace) + "\\n" + res.substring(lastSpace, res.length);
			hasBroken = true;
			charID = -1;
			doNotAddChar = true;
			breaks++;
		} else if (charID >= textBreakLimit && chars[iter] == " ") {
			if (pageonbreak) {
				if (breaks % 2 != 0) {
					res = res.substring(0, lastSpace) + "\\p" + res.substring(lastSpace, res.length)
				} else {
					res = res.substring(0, lastSpace) + "\\n" + res.substring(lastSpace, res.length)
				}
			} else {
				res = res.substring(0, lastSpace) + "\\l" + res.substring(lastSpace, res.length)
			}
			charID = -1;
			doNotAddChar = true;
			breaks++;
		}
		
		if (!doNotAddChar) {
		
			res += chars[iter];
			
			if (["\\n", "\\l", "\\p"].indexOf(chars[iter]) > -1) {
				charID = -1;
				breaks++;
			}
			
		} else {
		
			doNotAddChar = false;
		
		}
	
		charID++;
	
	}
	
	if (["\n", "\l", "\p"].indexOf(res.charAt(res.length-1)) > -1) {
		res = res.substring(0, res.length-2);
	}
	
	return res;

}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function repArgs(data, args, arg) {

	var res = data;

	for (let m = 1; m <= args; m++) {
	
		res = res.split("%ARG_"+m);
		res = res.join(arg[m+1]);
		
	}
	
	return res.replace(/\&sp/g, " ").split(/\n/g);

}

function getHighestArgFromTemplate(template) {

	var lns = template.split('\n');
	var cHighest = 0;
	
	for (let i = 0; i < lns.length; i++) {
	
		while (lns[i].includes("%ARG_")) {
			let argInt = lns[i].substring(lns[i].indexOf("%ARG_")+5, lns[i].length).split(" ")[0];
			if (parseInt(argInt) > cHighest) {
				cHighest = parseInt(argInt);
			}
			
			lns[i] = lns[i].replace("%ARG_"+parseInt(argInt).toString(), "");
		}
	
	}
	
	return cHighest;

}

getHighestArgFromTemplate(`
msg %ARG_1 0x4
msg %ARG_2 0x4
msg %ARG_3 0x4
`); //holy shit it actually worked first try, no debugging, wtf???

//converts templates to strings
for (let f = 0; f < Object.keys(allScripts).length; f++) {
	
	let keys = Object.keys(allScripts);
	
	allScripts[keys[f]] = allScripts[keys[f]];
	
}

var numsAsStrings = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

function isNonHexInt(n) {

	let chars = n.split("");
	
	if (parseInt(n) == NaN) {
		return false;
	}
	
	for (let i = 0; i < chars.length; i++) {
		
		if (numsAsStrings.indexOf(chars[i]) == -1) {
			return false;
		}
		
	}
	
	return true;

}

function conformHex(n, tableRef, decTable) {

	if (isHex(n)) {
		return n;
	} else if (isNonHexInt(n)) {
		//is decimal int
		return toXSEhex(parseInt(n));
	} else {
		if (tableRef == undefined) {
			return false;
		}
		if (decTable) {
			return toXSEhex(parseInt(tableRef[n]));
		}
		return tableRef[n]; //must be string
	}

}

String.prototype.lstrip = function() 
{
	return String(this).replace(/^@+|@+$/g, '');
};

function addFuncsFromCache() {
	
	let vals = JSON.parse(localStorage.func);
	
	let keys = Object.keys(vals);
	let values = Object.values(vals);
	
	for (let i = 0; i < keys.length; i++) {
	
		allScripts[keys[i]] = values[i];
	
	}
	
}

if (typeof localStorage.func == 'undefined' || !(localStorage.func.length > 0)) {
	
	localStorage.func = JSON.stringify({});
	
} else {

	addFuncsFromCache();

}

function getXSE(text) {
    let lines = (text+"\n").split(/\n/);
	let actualLength = lines.length;
    let header1 = "#dynamic "+goff;
	let scriptText = "\n";
	let header2 = "\n#org @start\n\n";
    let body = "";
    let footer = "";
	
	let endsNeeded = 1;
	
	let cEndingText = "\n\nend";
	
	let globalLine = 0;
	
	let isFuncDef = false;
	let funcName = "";
	
	let oldFuncValue = isFuncDef;

	//console.log(goff)
    for(var i = 0; i < lines.length; i++, globalLine++) {
        var cline = lines[i];

        if (cline.charAt(0) != ";") {
        var arg = cline.split(" ");
		
		arg = removeComments(arg);
		
		if (isFuncDef == false) {

        switch(arg[0].toLowerCase()) {
			case "&comstart":
				oldFuncValue = isFuncDef;
				isFuncDef = "com";
				break;
			case "$funcstart":
				if (arg.length < 2) {
					success = false;
					alert("$funcstart requires a func name. Exception on line "+(globalLine+1)+".");
					return;
				}
				noliNewLineAre = true;
				oldFuncValue = isFuncDef;
				isFuncDef = true;
				funcName = arg[1];
				allScripts[funcName] = ``;
				break;
			case "compile":
				arg = derefAllFromIndex(arg, 1);
				
				alert(getXSE(arg.slice(1).join(" ")));
				
				break;
			case "setlabelname":
				arg = derefAllFromIndex(arg, 1);
				
				autolabelname = arg[1];
				
				break;
            case "applymovement":
            case "move":
			case "applymovementnowait":
            case "movenowait":
				arg = derefAllFromIndex(arg, 1);
                body += "applymovement "+arg[1]+" "+getOff();

                if (!(arg[0] == "movenowait")) {
                    body += "\nwaitmovement 0x0";
                }

                footer += footer.addOrg(parseMoves(arg.slice(2)));
                break;
			case "bufferattack":
				arg[1] = arg[1].toLowerCase();
				
				body += "bufferattack "+arg[1]+" "+conformHex(arg[2], attacktable);
				
				break;
			case "bufferpokemon":
				arg[1] = arg[1].toLowerCase();
				
				body += "bufferpokemon "+arg[1]+" "+conformHex(arg[2], pokemontable, true);
				
				break;
			case "func":
			case "fcall":
				
				arg[1] = arg[1].toLowerCase();
				
				if (Object.keys(allScripts).indexOf(arg[1]) == -1) {
					success = false;
					alert("Function "+arg[1]+" not defined. Edit scripts.js to create a definition.");
					return;
				}
				
				let thisHighestArg = getHighestArgFromTemplate(allScripts[arg[1]]);
				
				if (Object.keys(allScripts).indexOf(arg[1]) == -1) {
				
				
					success = false;
					alert("Function specified on line "+(globalLine+1)+" does not exist. Please create a definition in scripts.js.");
					return;
				
				}
				
				if (arg.length-2 != thisHighestArg) {
					success = false;
					alert("Mismatch between specified external function arguments and actual arguments provided.");
				}
				
				lines.splice(i+1, 0, repArgs(allScripts[arg[1]], thisHighestArg, arg));
				lines = lines.flat();
				
				noliNewLineAre = true;
				
				break;
			case "setbreaklimit":
			case "breaklimit":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				textBreakLimit = parseInt(arg[1]);
				
				break;
			case "pageonbreak":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				pageonbreak = ( arg[1] == 'true' );
				
				break;
			case "if":
				body += "if "+arg.slice(1).join(" ");
				break;
			case "goto":
				arg = derefAllFromIndex(arg, 1);
				
				body += "goto "+arg.slice(1).join(" ");
				
				break;
			case "l":
			case "lock":
				body += "lock";
				break;
			case "lf":
			case "lockface":
			case "lockfaceplayer":
				body += "lock\nfaceplayer";
				break;
			case "face":
			case "faceplayer":
				body += "faceplayer";
				break;
			case "rel":
			case "release":
				if (cLab != "@start" && !activeLabel) {
					success = false;
					alert("Release statements must either be in @start or another label. This release is not in any label. Exception on line "+(globalLine+1)+".");
				}
				body += "release";
				break;
			case "@":
			case "lbl":
			case "org":
			case "label":
				arg[1] = "@"+arg[1].lstrip("@");
				activeLabel = true;
				endsNeeded++;
				if (cLab == "@start" && endsNeeded == 2) {
					body += "\nend\n";
				}
				cLab = arg[1];
				if (arg[1].charAt(0) != "@") {
					success = false;
					alert("Labels must start with @. Error on line "+(globalLine+1)+".");
				}
				if ((arg[1].match(/@/g) || []).length > 1) {
					success = false;
					alert("Labels must start with @, but cannot contain @ elsewhere, only the first char. Pls fix. Exception on line "+(globalLine+1)+".");
					return;
				}
				body += "\n#org "+arg[1]+"\n";
				break;
			case "ret":
			case "return":
				if (!activeLabel) {
					success = false;
					alert("Ret used on line "+(globalLine+1)+", but no corresponding lbl.");
					return;
				}
				activeLabel = false;
				endsNeeded--;
				endCalled = true;
				body += "\nreturn\n";
				break;
			case "end":
				activeLabel = false;
				endCalled = true;
				body += "\nend";
				endsNeeded--;
				break;
			case "const":
			case "define":
			case "sconst":
				if (arg.length < 3) {
					success = false;
					alert("Consts require a name and value (2 params). Params given: "+(globalLine+1)+".");
				}
				if (["@", "%", "!", "#", "$"].indexOf(arg[1].charAt(0)) == -1 || Object.keys(constTable).indexOf(arg[1]) > -1) {
					success = false;
					alert("Const on line "+(globalLine+1)+" either does not start with const identifier (%) or has already been defined.");
				}
				let constVal = arg.slice(2).join(" ");
				constVal = constVal.split(" ").join("&sp");
				constTable[arg[1]] = constVal;
				noliNewLineAre = true;
				break;
			case "setflag":
			case "sf":
				arg = derefAllFromIndex(arg, 1);
				
				body += "setflag "+arg[1];
				
				break;
			case "clearflag":
			case "cf":
			case "resetflag":
				arg = derefAllFromIndex(arg, 1);
				
				body += "clearflag "+arg[1];				
				
				break;
            case "warp":
			case "warpto":
				arg = derefAllFromIndex(arg, 1);
                body += "warp 0x"+parseInt(arg[1], 16)+" 0x"+parseInt(arg[2], 16)+" 0x"+parseInt(arg[3], 16)+" 0x0 0x0";
                break;
			case "setautobreak":
			case "autobreak":
				arg = derefAllFromIndex(arg, 1);
				
				autobreak = ( arg[1] == 'true' );
				
				break;
            case "setspeed":
			case "setmovespeed":
				arg = derefAllFromIndex(arg, 1);
                if (arg[1]+arg[2] == "veryslow" || arg[1] == "veryslow" || arg[1] == "vslow") {
                    if (whichGame == "rse") {
                        alert("The 'very slow' speed did not exist in R/S/E. Please change the game to FR/LG if you're working with that game, or adjust the speed to 'slow', 'normal', 'fast', 'faster', or 'fastest' if you're working with R/S/E.");
                        success = false;
                    } else {
                        cSpeed = "veryslow";
                    }
                } else {
					if (arg[1]+arg[2] == "veryslow") {
						cSpeed = "veryslow";
					} else {
						cSpeed = arg[1];
					}
                }
                noliNewLineAre = true;
                break;
            case "msgbox":
            case "msg":
				if (arg.length < 3) {
					success = false;
					alert("msgbox requires 2 arguments, "+(globalLine+1)+" provided.");
				}
				arg = derefAllFromIndex(arg, 1);
				
				for (let g = 1; g < arg.length-1; g++) {
					if (arg[g].indexOf(String.raw`\n`) > -1 && arg[g].indexOf(String.raw`\\n`) == -1) {
						success = false;
						alert("Use \\\\n not \\n. Exception on line "+(globalLine+1)+".");
						return;
					}
					arg[g] = arg[g].replace("\\\\n", "\\n");
				}
				
				if (!(isHex(arg[arg.length-1]))) {
					success = false;
					alert("last argument of msgbox is not a msgbox type (hex int). This error could also be caused by failing to escape \\n in an externally-called msgbox. Use \\\\n for external strings, not \\n.");
				}
            	let txtOff = getOff();
                body += "msgbox "+txtOff+" "+arg.slice(-1)[0];
                footer += footer.addOrg("= "+doLines(arg.slice(1, -1).join(" "))); //Adds our text data.
                break;
			case "xse":
			case "xsed":
			case "raw":
				if (arg[0].toLowerCase() == "xsed") {
					arg = derefAllFromIndex(arg, 1);
				}
				
				body += arg.slice(1).join(" ");
				
				break;
			case "giveitem":
			case "item":
				arg = derefAllFromIndex(arg, 1);
				
				arg[1] = conformHex(arg[1], itemstable, true);
				
				arg[2] = conformHex(arg[2]);
				
				body += "giveitem "+arg[1]+" "+arg[2]+" MSG_OBTAIN";
				
				break;
            case "givepokemon":
            case "pokemon":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				arg[3] = arg[3].toLowerCase().replace("-", "").replace("_", "");
                
				arg[1] = conformHex(arg[1], pokemontable, true);
				arg[2] = conformHex(arg[2]);
				arg[3] = conformHex(arg[3], itemstable, true);
				
				if (arg.indexOf(false) > -1) {
					success = false;
					alert("String given for givepokemon call in inappropriate place. Only item and pokemon IDs can be strings, not the level.");
					return;
				}
			
                body += "givepokemon "+arg[1]+" "+arg[2]+" "+arg[3]+" 0x0 0x0 0x0";

                break;
			case "":
				noliNewLineAre = true;
            default:
				if (arg[0].charAt(0) == "@" && arg[0].length > 1) { //label name case
					lines.splice((i+1), 0, "@ "+arg[0]);
					continue;
				} else { //true default case
					arg = derefAllFromIndex(arg, 1);
					body += arg.join(" ");
					break;
				}
        }
		
		} else if (isFuncDef == true) {
			noliNewLineAre = true;
			//funcdef
			if (arg[0] == "$funcend") {
				isFuncDef = false;
				funcName = "";
			} else {
				let val = arg.slice(0).join(" ");
				if (autosav) {
					let obj = JSON.parse(localStorage.func);
					if (typeof obj[funcName] == 'undefined') {
						obj[funcName] = "";
					}
					obj[funcName] += val;
					localStorage.func = JSON.stringify(obj);
				}
				allScripts[funcName] += val;
			}
			
		} else if (isFuncDef == "com") {
			if (arg[0] == "&comend"){
				isFuncDef = oldFuncValue;
			}
		}
        
        if (!noliNewLineAre) {
            body += "\n";
        }
        noliNewLineAre = false;

        }

    }
	
	if (activeLabel) {
		success = false;
		alert("Label not closed. Use 'end' to close a label.");
	}
	
	if (!endCalled) {
		body += "\nend\n";
	}
	
	let k = String.raw`kek`.replace("kek", body);
	
	if ({objk: k.replace(/end/g, "").replace(/\n/g, "")}.objk.length == 0) {
		
		return "nothing to compile :(";
	}

    return header1+scriptText+header2+body+"\n"+footer+"\n\n";
}










function calcProgramBytes(text) {

    var lines = (text+"\n").split(/\n/);
    var bytesToOffset = 0;

    for(var i = 0; i < lines.length; i++) {
		var cline = lines[i];
        if (cline.charAt(0) != ";") {
        var arg = cline.split(" ");

        switch(arg[0].toLowerCase()) {
            case "applymovement":
            case "movement":
            case "mvmt":
            case "move":
            case "movenowait":
            case "movenowaitmovement":
            case "moven":
            case "moveno":
            case "movewait":
            case "movewithwait":
            case "movewithawait":
            case "movewithwaitmovement":
            case "movewithawaitmovement":
                bytesToOffset += arg.length;
                break;
            case "wrp":
            case "warp":
                bytesToOffset += 6;
                break;
            case "msgbox":
            case "msg":
            case "text":
            case "txt":
            case "filltext":
            case "domsgbox":
            case "message":
            case "messagebox":
                bytesToOffset += arg.slice(1).join(" ").length;
                break;
            case "givepokemon":
            case "givepoke":
            case "gp":
            case "addpokemon":
            case "pokemongive":
            case "poke":
            case "pokemon":
                if (text.includes("autoobtain false")) {
                    bytesToOffset += arg.length;
                }
                bytesToOffset += arg.length;
                break;
            default:
                bytesToOffset += arg.length+2;
                break;
        }
        }

    }

	return bytesToOffset;

}










var goff = document.getElementById("offset").value;
var whichGame = "rse";

var inbutton = document.getElementById("in");

if (localStorage["inputdata"] != "undefined" && localStorage["inputdata"] != undefined && localStorage["inputdata"] != null) {
    FSEeditor.setValue(localStorage["inputdata"], 0);
}




function convert() {
	resetAll();

    var inbutton = document.getElementById("in");
    var outbutton = document.getElementById("out");

    var rse = document.getElementById("rse").selected;
    var frlg = document.getElementById("frlg").selected;

    goff = document.getElementById("offset").value;
    var stat = document.getElementById("status");

    if (rse) {
        whichGame = "rse";
    } else {
        whichGame = "frlg";
    }

    var intext = FSEeditor.getValue();
    localStorage["inputdata"] = FSEeditor.getValue();

    var res = getXSE(intext);

    if (success) {
        outbutton.innerHTML = res;

        outbutton.select();
        document.execCommand("copy");
        window.getSelection().removeAllRanges();
		
		FSEeditor.focus();
        
        stat.innerHTML = "Conversion successful. Output data copied to clipboard.";
    } else {
        stat.innerHTML = "Conversion unsuccessful. An alert box should have explained the error.";
        success = true;
    }
	
	outbutton.scrollTop = 0;

}






















        </script>
    </body>
</html>
