<!DOCTYPE HTML>
<html>
    <head>
        <title>FSE v1.0</title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="./tables.js" type="text/javascript"></script>
		<script id="sc" src="./scripts.js" type="text/javascript"></script>
    </head>
    <body style="font-family: 'Trebuchet MS'; overflow: hidden;">
        <p style="margin-top: 1.5%; top: 0%;">Starting Offset:</p>
        <input id="offset" type="text" style="position: absolute; top: 6.2%;" value="0x800000"></input>
        <select style="position: absolute; top: 1px;">
            <option id="rse" value="1" selected>Ruby/Sapphire/Emerald</option>
            <option id="frlg" value="2">FireRed/LeafGreen</option>
        </select>
		<div style="position: absolute; left: 37%; top: 6.1%;">
			<label for="efont">Editor Font Size:&nbsp;</label>
			<input type="text" value="15" name="efont" id="ef" style="position: relative; left: 0.5%;"></input>
		</div>
		<div style="position: absolute; left: 37%; top: 10%;">
			<label for="ofont">Output Font Size:</label>
			<input type="text" value="14" name="ofont" id="of"></input>
		</div>
        <div style="position: absolute; left: 15%; top: 6.1%;">
        <label for="ts">Editor Theme:</label>
        <select name="ts" id="theme" style="position: relative;" onclick="changeMode();" defer>

        	<option>ambiance</option>
        	<option>chaos</option>
        	<option>chrome</option>
        	<option>clouds</option>
        	<option>clouds_midnight</option>
        	<option>cobalt</option>
        	<option>crimson_editor</option>
        	<option>dawn</option>
        	<option>dracula</option>
        	<option>dreamweaver</option>
        	<option>eclipse</option>
        	<option>github</option>
        	<option>gob</option>
        	<option>gruvbox</option>
        	<option>idle_fingers</option>
        	<option>iplastic</option>
        	<option>katzenmilch</option>
        	<option>kr_theme</option>
        	<option>kuroir</option>
        	<option>merbivore</option>
        	<option>merbivore_soft</option>
        	<option>mono_industrial</option>
        	<option>monokai</option>
        	<option>nord_dark</option>
        	<option>pastel_on_dark</option>
        	<option>solarized_dark</option>
        	<option>solarized_light</option>
        	<option>sqlserver</option>
        	<option>terminal</option>
        	<option>textmate</option>
        	<option>tomorrow</option>
        	<option>tomorrow_night</option>
        	<option>tomorrow_night_blue</option>
        	<option>tomorrow_night_bright</option>
        	<option>tomorrow_night_eighties</option>
        	<option selected>twilight</option>
        	<option>vibrant_ink</option>
        	<option>xcode</option>


        </select>
    	</div>
        <br>
        <br>
        <button id="convert_button" onclick="convert();" style="position: absolute; top: 11%; left: 11.1%;">Convert/Expand (Ctrl+Q)</button>
        <button id="help-button" onclick="launchHelp();" style="position: absolute; top: 11%;">Documentation/Help</button>
        <br>
        <br>
        
        <div id="in" style="position: absolute; top: 19%; right: 0%; left: .5%; bottom: 0; margin-right: 55%;"></div>
		<p style="position: absolute; left: 0.6%; top: 13.65%;">FSE code (input)</p>
		<p style="position: absolute; left: 46%; top: 13.65%;">XSE code (output; automatically copied to clipboard)</p>
        <textarea id="out" cols="85" rows="33" readonly style="position: absolute; left: 46%; top: 18.95%; background-color: black; color: white; font-family: 'Trebuchet MS'; overflow-y: scroll; resize: none;"></textarea>
        <br>
		<div style="position: absolute; top: -2.5%; padding-top: 1%; left: 15%; line-height: 1;">
        <p id = "status">Welcome to FSE. This message will tell you whether or not a conversion was successful.</p>
		</div>
        <script src="./ace/ace.js" type="text/javascript" charset="utf-8"></script>
        <script defer>
		
		
		
		
		
String.prototype.replaceAt = function(index, replacement) {
    return this.substr(0, index+1) + replacement + this.substr(index + replacement.length);
}

var keysDown = [];
var keysUp = [];





function launchHelp() {

	window.open("https://github.com/ps4star/FSE/blob/master/ref.md");

}



var themeSel = document.getElementById("theme");

//Code editor stuff
var FSEeditor = ace.edit("in", {wrap: true});
FSEeditor.setTheme("ace/theme/xcode");
FSEeditor.session.setMode("ace/mode/assembly_x86");

FSEeditor.setValue("using namespace stdlib\n\n");

var csetfont = "20";
var offont = document.getElementById("out").style.fontSize;

document.addEventListener("keyup", function(e) {

    delete keysDown[keysDown.indexOf(e.key)];
	
	keysUp.push(e.key);
	
	

});

function updateFonts() {
	csetfont = document.getElementById("ef").value;
	offont = document.getElementById("of").value;
	
	document.getElementById("out").style.fontSize = offont+'px';
}

const noCompString = "Expansion statements successfully processed! Hit compile again to compile your code. Ctrl+Z to undo.";

$("#ef").on("change keyup paste", function(){
	updateFonts();
    FSEeditor.setOptions({fontSize: csetfont+"pt"});
});

$("#of").on("change keyup paste", function(){
    updateFonts();
});

if (localStorage["selection"] == "undefined") {
	localStorage["selection"] = "twilight";
}

let ops = [];
for (var i = 0; i < themeSel.options.length; i++) {
	ops.push(themeSel.options[i].text);
}
themeSel.selectedIndex = ops.indexOf(localStorage["selection"]);

function changeMode() {
	try {
		localStorage["selection"] = themeSel.options[themeSel.selectedIndex].text;
	} catch(e) {
		localStorage["selection"] = "twilight";
	}
	FSEeditor.setTheme("ace/theme/"+localStorage["selection"]);
	document.getElementById('in').style.fontSize=csetfont;
}


document.getElementById('in').style.fontSize=csetfont;

FSEeditor.focus();

FSEeditor.clearSelection();

var noliNewLineAre = false;


function determineType(data) {
    if (data.indexOf("#raw") > -1) {
        return "#raw";
    } else if (data.charAt(0)+data.charAt(1) == "= ") {
        return "text";
    }
}


function calcBytes(dataType, data) {
    if (dataType == "#raw") {
        return data.split("\n").length;
    } else if (dataType == "text") {
        return data.length-2;
    }
}





var currOff = 0;

function getOff() {
	let ret = "@"+autolabelname+currOff.toString();
	return ret;
}

function nextOff() {
	currOff++;
}


String.prototype.addOrg = function(data) {
    var toReturn = "#org "+getOff()+"\n"+data;
    nextOff();
    goff = parseInt(goff, 16);
    goff += calcBytes(determineType(data), data);
    goff++; //Adds the extra byte to avoid overwriting terminators
    if (determineType(data) == "text") {
        goff++; //padding for strings. may not be necessary.
    }
    goff = "0x"+goff.toString(16).toUpperCase();
    return toReturn+"\n\n";
}


var cSpeed = "normal";

function isHex(n) {
	return (n.charAt(0)+n.charAt(1) == "0x");
}

function parseMoves(input) {

    if (whichGame == "rse") {
        var currentTable = rseMoveTable;
    } else {
        var currentTable = frlgmovetable;
    }

    var res = "";

    for(var i = 0; i < input.length; i++) {
		input[i] = input[i].replace("u", "up").replace("d", "down").replace("l", "left").replace("r", "right");
		if (input[i] == "") {
			success = false;
			alert("Unnecessary space/empty string in applymovement move sequence.");
		}
        if (["up", "down", "left", "right"].indexOf(input[i]) > -1) {
            input[i] += cSpeed;
        }
		if (isHex(input[i])) {
			res += "#raw "+input[i]+"\n";
		} else {
			res += "#raw "+currentTable[input[i]]+"\n";
		}
    }
    return res+"#raw 0xFE";

}

function pokeToID(poke) {

    return pokemontable[poke.toLowerCase()];

}

function itemToID(item) {

    return itemstable[item.toLowerCase()];

}

function attackToID(attack) {

	return attacktable[attack.toLowerCase()];
	
}


var success = true;


function toXSEhex(hexnum) {
    return "0x"+hexnum.toString(16).toUpperCase();
}

var constTable = {};

function deref(n) {

	if (Object.keys(constTable).indexOf(n) > -1) {
		return constTable[n];
	} else {
		return n;
	}
	
}

function derefAllFromIndex(arr, index) {

	for (let v = index; v < arr.length; v++) {
	
		arr[v] = deref(arr[v]).split("&sp");
	
	}
	
	return arr.flat();

}

function derefAllFromIndexFcall(arr, index) {

	for (let v = index; v < arr.length; v++) {
	
		arr[v] = deref(arr[v]);
	
	}
	
	return arr.flat();

}

function removeComments(arr) {

	let res = [];

	for (let e = 0; e < arr.length; e++) {
	
		if (arr[e].charAt(0) == ";") {
			break;
		}
		
		res.push(arr[e]);
	
	}
	
	return res;

}

function addFuncsFromCache() {
	
	let vals = JSON.parse(localStorage.func);
	
	let keys = Object.keys(vals);
	let values = Object.values(vals);
	
	for (let i = 0; i < keys.length; i++) {
	
		allScripts[keys[i]] = values[i];
	
	}
	
}

function loadCache() {

	if (typeof localStorage.func == 'undefined' || localStorage.func == "undefined" || !(localStorage.func.length > 0)) {
		
		localStorage.func = JSON.stringify({});
		
	} else {

		addFuncsFromCache();

	}
	
}

loadCache();

function clone(obj) { //copied from SO
    let k = Object.keys(obj);
	
	let res = {};
	
	for (let iter = 0; iter < k.length; iter++) {
	
		res[k[iter]] = obj[k[iter]];
		
	}
	
	return res;
		
}

const originalAllScripts = clone(allScripts); //for some reason Object.assign wasn't working here???

var cLab = "@start";
var endCalled = false;
var activeLabel = false;

var textBreakLimit = 30;
var originalTextBreakLimit = textBreakLimit;

var pageonbreak = false;

var autobreak = true;

var autolabelname = "offset";
var originalautolabelname = autolabelname;

var autosav = true;

function resetAll() {
	allScripts = clone(originalAllScripts);

	currOff = 0;
	constTable = {};
	cLab = "@start";
	
	lockReleaseText = "";
	
	endCalled = false;
	activeLabel = false;
	
	pageonbreak = false;
	textBreakLimit = originalTextBreakLimit;
	
	autobreak = true;
	
	autolabelname = originalautolabelname;
	
	autosav = true;
	
	FSEeditor.clearSelection();
}



function doLines(n) {

	if (!autobreak) {
		return n;
	}

	var chars = n.split("");
	var charID = 0;
	var hasBroken = false;
	var res = "";
	var doNotAddChar = false;
	
	var lastSpace = 0;
	
	var breaks = 0;
	
	let kek = "meme meme2";
	
	for (let iter = 0; iter < chars.length; iter++) {
	
		if (chars[iter] == " ") {
			lastSpace = iter+breaks;
		}
	
		if (charID >= textBreakLimit && (!hasBroken && chars[iter] == " ")) {
			res = res.substring(0, lastSpace) + "\\n" + res.substring(lastSpace, res.length);
			hasBroken = true;
			charID = -1;
			doNotAddChar = true;
			breaks++;
		} else if (charID >= textBreakLimit && chars[iter] == " ") {
			if (pageonbreak) {
				if (breaks % 2 != 0) {
					res = res.substring(0, lastSpace) + "\\p" + res.substring(lastSpace, res.length)
				} else {
					res = res.substring(0, lastSpace) + "\\n" + res.substring(lastSpace, res.length)
				}
			} else {
				res = res.substring(0, lastSpace) + "\\l" + res.substring(lastSpace, res.length)
			}
			charID = -1;
			doNotAddChar = true;
			breaks++;
		}
		
		if (!doNotAddChar) {
		
			res += chars[iter];
			
			if (["\\n", "\\l", "\\p"].indexOf(chars[iter]) > -1) {
				charID = -1;
				breaks++;
			}
			
		} else {
		
			doNotAddChar = false;
		
		}
	
		charID++;
	
	}
	
	if (["\n", "\l", "\p"].indexOf(res.charAt(res.length-1)) > -1 || res.charAt(res.length-1) == " ") {
		res = res.substring(0, res.length-2);
	}
	
	return res;

}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

var specialArgs = ["A", "P", "I"];

function getHighestArgFromTemplate(template) {

	var lns = template.split('\n');
	var cHighest = -1;
	
	for (let i = 0; i < lns.length; i++) {
	
		while (lns[i].includes("%ARG")) {
			if (specialArgs.indexOf(lns[i].charAt(lns[i].length-1)) > -1) {
				lns[i] = lns[i].substring(0, (lns[i].length+1) - specialArgs[specialArgs.indexOf(lns[i].charAt(lns[i].length-1))].length);
			}
			let argInt = lns[i].substring(lns[i].indexOf("%ARG")+4, lns[i].length).split(" ")[0];
			if (parseInt(argInt) > cHighest) {
				cHighest = parseInt(argInt);
			}
			
			lns[i] = lns[i].replace("%ARG"+parseInt(argInt).toString(), "");
			if (parseInt(argInt) == 0) {
				success = false;
				alert("Arg 0 does not exist.");
				return;
			}
		}
	
	}
	
	return cHighest;

}

getHighestArgFromTemplate(`
msg %ARG1 0x4
msg %ARG2 0x4
msg %ARG3 0x4
`); //holy shit it actually worked first try, no debugging, wtf???

//converts templates to strings
for (let f = 0; f < Object.keys(allScripts).length; f++) {
	
	let keys = Object.keys(allScripts);
	
	allScripts[keys[f]] = allScripts[keys[f]];
	
}

var numsAsStrings = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

function isNonHexInt(n) {

	let chars = n.split("");
	
	if (parseInt(n) == NaN) {
		return false;
	}
	
	for (let i = 0; i < chars.length; i++) {
		
		if (numsAsStrings.indexOf(chars[i]) == -1) {
			return false;
		}
		
	}
	
	return true;

}

function prepCase(n) {
	let nc = n.split("");
	
	for (let h = 0; h < nc.length; h++) {
		
		if (h > 1) {
			nc[h] = nc[h].toUpperCase();
		}
		
	}
	
	return nc.join("");
}

function conformHex(n, tableRef, decTable) {

	if (isHex(n)) {
		return prepCase(n);
	} else if (isNonHexInt(n)) {
		//is decimal int
		return prepCase(toXSEhex(parseInt(n)));
	} else {
		if (tableRef == undefined) {
			return false;
		}
		if (decTable) {
			return prepCase(toXSEhex(parseInt(tableRef[n])));
		}
		return prepCase(tableRef[n]); //must be string
	}

}

function repArgs(data, args, arg, cHighest) {

	var res = data;

	for (let m = 1; m <= args; m++) {
	
		res = res.split("%ARG"+m+"P");
		res = res.join(conformHex(arg[m+1], pokemontable, true));
		
		res = res.split("%ARG"+m+"I");
		res = res.join(conformHex(arg[m+1], itemstable, true));
		
		res = res.split("%ARG"+m+"A");
		res = res.join(conformHex(arg[m+1], attacktable, true));
		
		res = res.split("%ARG"+m+"H");
		res = res.join(conformHex(arg[m+1]));
		
		res = res.split("%ARG"+m);
		res = res.join(arg[m+1]);
		
	}
	
	return res.replace(/\&sp/g, " ").split(/\n/g);

}

String.prototype.lstrip = function() 
{
	return String(this).replace(/^@+|@+$/g, '');
};

//expand functions o_o
	

String.prototype.swapChars = function(arg1, arg2) {

	let res = this;

	for (let c = 0; c < res.length; c++) {
		
		if (res.charAt(c) == arg1) {
			res = res.substring(0, c) + arg2 + res.substring(c+1, res.length);
		} else if (res.charAt(c) == arg2) {
			res = res.substring(0, c) + arg1 + res.substring(c+1, res.length);
		}
		
	}
	
	return res;

}

window.onload = function() {
	changeMode();
	FSEeditor.setOptions({fontSize: "15pt"});
	FSEeditor.clearSelection();
	
}

document.addEventListener("keydown", function(e) {

    keysDown.push(e.key);

    if (keysDown.indexOf("Control") > -1 && keysDown.indexOf("q") > -1) {
        convert();
		keysDown = [];
    }
	
	if (keysDown.indexOf("Control") > -1 && keysDown.indexOf(";") > -1) {
        convertExpands();
    }
	
	keysUp = [];

});

function getXSE(text) {
    let lines = (text.replace(new RegExp("    ", "g"), "").replace(new RegExp("\t", "g"), "").replace(new RegExp("\r\n", "g"), "\n").replace(new RegExp("%PL", "gi"), "[player]").replace(new RegExp("%RI", "gi"), "[rival]")+"\n").split(/\n/);
	let actualLength = lines.length;
    let header1 = "#dynamic "+goff;
	let scriptText = "\n";
	let header2 = "\n#org @main\n\n";
    let body = "";
    let footer = "";
	
	let endsNeeded = 1;
	
	let cEndingText = "\n\nend";
	
	let globalLine = 0;
	
	let isFuncDef = false;
	let funcName = "";
	
	let oldFuncValue = isFuncDef;
	
	let noCompile = false;
	
	let allBef = [];
	let lmode = "loop";
	
	let loopTimes = 0;
	
	let cLoopData = "";
	
	let loopOff = 0;
	let loopMult = 1;

	//console.log(goff)
    for(var i = 0; i < lines.length; i++) {
        var cline = lines[i];

        if (cline.charAt(0) != ";") {
		
        var arg = cline.split(" ");
		
		arg = removeComments(arg);
		
		for (let b = 0; b < arg.length; b++) {
			if (arg[b].includes("\;")) {
				arg[b] = arg[b].split("\\;").join(";");
			}
			if (b > 0 && arg[b] == "") {
				delete arg[b];
			}
		}
		
		if (isFuncDef == false) {

        switch(arg[0].toLowerCase()) {
			case "&comstart":
				oldFuncValue = isFuncDef;
				isFuncDef = "com";
				break;
			case "$autosav":
				arg = derefAllFromIndex(arg, 1);
				
				if (arg.length < 2) {
					success = false;
					alert("$autosav requires 1 argument. Exception on line .");
					return;
				}
				
				autosav = ( arg[1] == 'true' );
				
				break;
			case "$funcstart":
				if (arg.length < 2 || arg[1].length < 1) {
					success = false;
					alert("$funcstart requires a func name. Exception on line.");
					return;
				}
				noliNewLineAre = true;
				oldFuncValue = isFuncDef;
				isFuncDef = true;
				funcName = arg[1];
				allScripts[funcName] = ``;
				
				localStorage.func[funcName] = ``;
				
				break;
			case "$clearall":
				localStorage.removeItem("func");
				break;
			case "compile":
				arg = derefAllFromIndex(arg, 1);
				
				alert(getXSE(arg.slice(1).join(" ")));
				
				break;
			case "setlabelname":
				arg = derefAllFromIndex(arg, 1);
				
				autolabelname = arg[1];
				
				break;
			case "compseqe":
			case "compareseqexplicit":
			case "compsequenceexplicit":
			case "compsequenceexplicit":
				let startOfArgSeqe = 2;
				
				arg = derefAllFromIndex(arg, 1);
				
				if (!isHex(arg[1])) {
					success = false;
					alert("compseqexplicit arg 1 is not hex. Exception on line.");
					return;
				}
				
				for (startOfArgSeqe; startOfArgSeqe < arg.length; startOfArgSeqe += 2) {
				
					body += "compare "+arg[1]+" "+conformHex(arg[startOfArgSeqe].toString());
					body += "\nif 0x1 goto "+arg[startOfArgSeqe+1]+"\n";
				
				}
				
				noliNewLineAre = true;
			
				break;
			case "offiter":
				arg = derefAllFromIndex(arg, 1);
				loopOff += Math.max(0, parseInt(arg[1]));
				noliNewLineAre = true;
				break;
			case "multiter":
				loopMult = Math.max(0, parseInt(arg[1]));
				noliNewLineAre = true;
				break;
			case "resiter":
				loopMult = 1;
				loopOff = 0;
				break;
			case "prepmsg":
			case "preparemsg":
			case "prepmsgnowait":
			case "preparemsgnowait":
				arg = derefAllFromIndex(arg, 1);
				
				body += "preparemsg "+conformHex(arg[1]);
				
				if (!arg[0].toLowerCase().includes("nowait")) {
					body += "\nwaitmsg";
				}
				
				break;
			case "compseq":
			case "compareseq":
			case "compsequence":
			case "comparesequence":
				let startOfArgSeq = 2;
				let sValue = 0;
				
				arg = derefAllFromIndex(arg, 1);
				
				if (!isHex(arg[1])) {
					success = false;
					alert("compseq arg 1 is not hex. Exception on line.");
					return;
				}
				
				for (startOfArgSeq; startOfArgSeq < arg.length; sValue++, startOfArgSeq++) {
				
					body += "compare "+arg[1]+" "+conformHex(sValue.toString());
					if (startOfArgSeq == arg.length-1) {
						body += "\nif 0x7F goto "+arg[startOfArgSeq]+"\n";
					} else {
						body += "\nif 0x1 goto "+arg[startOfArgSeq]+"\n";
					}
				
				}
				
				noliNewLineAre = true;
				
				break;
			case "applymovementreverse":
			case "applymovementnowaitreverse":
			case "movereverse":
			case "mover":
			case "movenowaitreverse":
            case "applymovement":
            case "move":
			case "applymovementnowait":
            case "movenowait":
				arg = derefAllFromIndex(arg, 1);
				if (arg[0].toLowerCase().includes("r")) {
					for (let thisa = 2; thisa < arg.length; thisa++) {
						arg[thisa] = arg[thisa].swapChars("u", "d");
						arg[thisa] = arg[thisa].swapChars("l", "r");
						
						arg[thisa] = arg[thisa].swapChars("up", "down");
						arg[thisa] = arg[thisa].swapChars("left", "right");
						
					}
				}
                body += "applymovement "+arg[1]+" "+getOff();

                if (!(arg[0].toLowerCase().includes("nowait"))) {
                    body += "\nwaitmovement 0x0";
                }

                footer += footer.addOrg(parseMoves(arg.slice(2)));
                break;
			case "bufferattack":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferattack "+arg[1]+" "+conformHex(arg[2], attacktable);
				
				break;
			case "bufferpokemon":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferpokemon "+arg[1]+" "+conformHex(arg[2], pokemontable, true);
				
				break;
			case "bufferfirstpokemon":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferfirstpokemon "+arg[1];
				
				break;
			case "bufferitem":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferitem "+arg[1]+" "+conformHex(arg[2], itemstable, true);
				
				break;
			case "buffernumber":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "buffernumber "+arg[1]+" "+conformHex(arg[2]);
				
				break;
			case "func":
			case "fcall":
			
				try {
			
					var reference = eval('allScripts.'+arg[1]);
					
				} catch(e) {
				

					
					success = false;
					alert("Specified function not found. Exception on line.");
					return;
				
				}
			
				if (arg.length < 2) {
					success = false;
					alert("fcall requires at least 1 argument. Exception on line.");
					return;
				}
				
				if (reference == "undefined" || typeof reference == "undefined") {
					success = false;
					alert("Function "+arg[1]+" not defined. Edit scripts.js to create a definition.");
					return;
				}
				
				let thisHighestArg = getHighestArgFromTemplate(reference);
				
				if (arg.length-2 < thisHighestArg) {
					success = false;
					alert("The function definition requires more arguments than actual arguments provided in fcall. Exception on line.");
					return;
				}
				
				let finalVal = repArgs(reference, thisHighestArg, arg, thisHighestArg);
				
				lines.splice(i+1, 0, finalVal);
				lines = lines.flat();
				
				noliNewLineAre = true;
				
				break;
			case "expstart":
			case "lstart":
			case "loopstart":
			case "loop":
				arg = derefAllFromIndex(arg, 1);
				
				if (arg[0].toLowerCase() == "expstart") {
				
					if (arg.length >= 3) {
						loopOff = parseInt(arg[2]);
					}
					
					if (arg.length == 4) {
						loopMult = parseInt(arg[3]);
					}
					
					if (arg.length > 4) {
						success = false;
						alert("!se can take at most 3 arguments. More than 3 provided.");
						return;
					}
				
					let indOfStart = 0;
					let indOfEnd = 0;
					
					let fselines = FSEeditor.getValue().split("\n");
					
					for (let c = 0; c < fselines.length; c++) {
					
						if (fselines[c].split(" ")[0] == "expstart") {
							indOfStart = c;
						}
						
						if (fselines[c] == "expend") {
							indOfEnd = c;
						}
					
					}
				
					allBef = fselines.slice(0, indOfStart);
					
					allAf = fselines.slice(indOfEnd);
					
					FSEeditor.setValue(FSEeditor.getValue().split("\n").slice(0, indOfEnd+1).flat().join("\n"));
				
					noCompile = true;
					
					lmode = "exp";
					
					var expStartIndex = i;
					var expEndIndex = lines.slice(i).indexOf("expend")+i;
					
				} else {
					lmode = "loop";
				}
				
				cLoopData = "";
				
				if (arg.length < 2 || arg[1].length < 1) {
					success = false;
					if (noCompile) {
						alert("Expansion statements require a times argument (like \"expstart 5\" loops the statement 5 times). They are essentially loops, after all.");
					} else {
						alert("loop requires a times argument.");
					}
					return;
				}
				
				loopTimes = parseInt(arg[1]);
				
				isFuncDef = "loop";
				
				noliNewLineAre = true;
				
				break;
			case "loopend":
			case "lend":
			case "expend":
				break;
			case "setbreaklimit":
			case "breaklimit":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				textBreakLimit = parseInt(arg[1]);
				
				break;
			case "pageonbreak":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				pageonbreak = ( arg[1] == 'true' );
				
				break;
			case "if":
				body += "if "+arg.slice(1).join(" ");
				break;
			case "goto":
				arg = derefAllFromIndex(arg, 1);
				
				body += "goto "+arg.slice(1).join(" ");
				
				break;
			case "l":
			case "lock":
				body += "lock";
				break;
			case "lf":
			case "lockface":
			case "lockfaceplayer":
				body += "lock\nfaceplayer";
				break;
			case "face":
			case "faceplayer":
				body += "faceplayer";
				break;
			case "rel":
			case "release":
				if (cLab != "@start" && !activeLabel) {
					success = false;
					alert("Release statements must either be in @start or another label. This release is not in any label. Exception on line.");
				}
				body += "release";
				break;
			case "@":
			case "lbl":
			case "org":
			case "label":
				arg[1] = "@"+arg[1].lstrip("@");
				activeLabel = true;
				endsNeeded++;
				if (cLab == "@start" && endsNeeded == 2) {
					body += "\nend\n";
				}
				cLab = arg[1];
				if (arg[1].charAt(0) != "@") {
					success = false;
					alert("Labels must start with @. Error on line "+(globalLine+1)+".");
				}
				if ((arg[1].match(/@/g) || []).length > 1) {
					success = false;
					alert("Labels must start with @, but cannot contain @ elsewhere, only the first char. Pls fix. Exception on line.");
					return;
				}
				body += "\n#org "+arg[1]+"\n";
				break;
			case "ret":
			case "return":
				if (!activeLabel) {
					success = false;
					alert("Ret used on line, but no corresponding lbl.");
					return;
				}
				activeLabel = false;
				endsNeeded--;
				endCalled = true;
				body += "\nreturn\n";
				break;
			case "end":
				activeLabel = false;
				endCalled = true;
				body += "\nend";
				endsNeeded--;
				break;
			case "const":
			case "define":
			case "sconst":
				if (arg.length < 3) {
					success = false;
					alert("Consts require a name and value (2 params). Params given: "+(globalLine+1)+".");
				}
				if (["@", "%", "!", "#", "$"].indexOf(arg[1].charAt(0)) == -1 || Object.keys(constTable).indexOf(arg[1]) > -1) {
					success = false;
					alert("Const on line either does not start with const identifier (%) or has already been defined.");
				}
				let constVal = arg.slice(2).join(" ");
				constVal = constVal.split(" ").join("&sp");
				constTable[arg[1]] = constVal;
				noliNewLineAre = true;
				break;
			case "setflag":
			case "sf":
				arg = derefAllFromIndex(arg, 1);
				
				body += "setflag "+arg[1];
				
				break;
			case "clearflag":
			case "cf":
			case "resetflag":
				arg = derefAllFromIndex(arg, 1);
				
				body += "clearflag "+arg[1];				
				
				break;
            case "warp":
			case "warpto":
				arg = derefAllFromIndex(arg, 1);
                body += "warp 0x"+parseInt(arg[1], 16)+" 0x"+parseInt(arg[2], 16)+" 0x"+parseInt(arg[3], 16)+" 0x0 0x0";
                break;
			case "setautobreak":
			case "autobreak":
				arg = derefAllFromIndex(arg, 1);
				
				autobreak = ( arg[1] == 'true' );
				
				break;
            case "setspeed":
			case "setmovespeed":
				arg = derefAllFromIndex(arg, 1);
                if (arg[1]+arg[2] == "veryslow" || arg[1] == "veryslow" || arg[1] == "vslow") {
                    if (whichGame == "rse") {
                        alert("The 'very slow' speed did not exist in R/S/E. Please change the game to FR/LG if you're working with that game, or adjust the speed to 'slow', 'normal', 'fast', 'faster', or 'fastest' if you're working with R/S/E.");
                        success = false;
                    } else {
                        cSpeed = "veryslow";
                    }
                } else {
					if (arg[1]+arg[2] == "veryslow") {
						cSpeed = "veryslow";
					} else {
						cSpeed = arg[1];
					}
                }
                noliNewLineAre = true;
                break;
			case "using":
				arg.shift();
				noliNewLineAre = true;
			case "writetop":
			case "loadlib":
			case "namespace":
			
				noliNewLineAre = true;
				
				let ref;
				let asKeys;
			
				if (arg.length < 2) {
					success = false;
					alert("namespace requires 1 argument. Exception on line.");
					return;
				}
				
				ref = eval("allScripts."+arg[1]);
				asKeys = Object.keys(ref);
				
				for (let thisName = 0; thisName < asKeys.length; thisName++) {
					
					allScripts[asKeys[thisName]] = ref[asKeys[thisName]];
					
				}
			
				break;
            case "msgbox":
            case "msg":
				if (arg.length < 3) {
					success = false;
					alert("msgbox requires 2 arguments, "+(globalLine+1)+" provided.");
				}
				arg = derefAllFromIndex(arg, 1);
				
				for (let g = 1; g < arg.length-1; g++) {
					if (arg[g].indexOf(String.raw`\n`) > -1 && arg[g].indexOf(String.raw`\\n`) == -1) {
						success = false;
						alert("Use \\\\n not \\n. Exception on line.");
						return;
					}
					arg[g] = arg[g].replace("\\\\n", "\\n");
				}
				
				if (!(isHex(arg[arg.length-1]))) {
					if (arg[arg.length-1].substring(0, 4) != "MSG_") {
						success = false;
						alert("last argument of msgbox is not a msgbox type (hex int). This error could also be caused by failing to escape \\n in an externally-called msgbox. Use \\\\n for external strings, not \\n.");
					}
				}
            	let txtOff = getOff();
                body += "msgbox "+txtOff+" "+arg.slice(-1)[0];
                footer += footer.addOrg("= "+doLines(arg.slice(1, -1).join(" "))); //Adds our text data.
                break;
			case "xse":
			case "xsed":
			case "raw":
				if (arg[0].toLowerCase() == "xsed") {
					arg = derefAllFromIndex(arg, 1);
				}
				
				body += arg.slice(1).join(" ");
				
				break;
			case "giveitem":
			case "item":
				arg = derefAllFromIndex(arg, 1);
				
				arg[1] = conformHex(arg[1], itemstable, true);
				
				arg[2] = conformHex(arg[2]);
				
				body += "giveitem "+arg[1]+" "+arg[2]+" MSG_OBTAIN";
				
				break;
            case "givepokemon":
            case "pokemon":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				arg[3] = arg[3].toLowerCase().replace("-", "").replace("_", "");
                
				arg[1] = conformHex(arg[1], pokemontable, true);
				arg[2] = conformHex(arg[2]);
				arg[3] = conformHex(arg[3], itemstable, true);
				
				if (arg.indexOf(false) > -1) {
					success = false;
					alert("String given for givepokemon call in inappropriate place. Only item and pokemon IDs can be strings, not the level.");
					return;
				}
			
                body += "givepokemon "+arg[1]+" "+arg[2]+" "+arg[3]+" 0x0 0x0 0x0";

                break;
			case "":
				noliNewLineAre = true;
            default:
				arg[0] = arg[0].toLowerCase();
				if (arg[0].charAt(0) == "@" && arg[0].length > 1) { //label name case
					lines.splice((i+1), 0, "@ "+arg[0]);
					continue;
				} else { //true default case
					arg = derefAllFromIndex(arg, 1);
					body += arg.join(" ");
					break;
				}
        }
		
		} else if (isFuncDef == true) {
			noliNewLineAre = true;
			//funcdef
			if (arg[0] == "$funcend") {
				isFuncDef = false;
				funcName = "";
			} else {
				let val = arg.slice(0).join(" ")+"\n";
				if (autosav) {
					let obj = JSON.parse(localStorage.func);
					if (typeof obj[funcName] == 'undefined') {
						obj[funcName] = "";
					}
					obj[funcName] += val;
					localStorage.func = JSON.stringify(obj);
				}
				allScripts[funcName] += val;
			}
			
		} else if (isFuncDef == "com") {
			if (arg[0].toLowerCase() == "&comend"){
				isFuncDef = oldFuncValue;
			}
			noliNewLineAre = true;
		} else if (isFuncDef == "loop") {
			let cond;
			if (noCompile) {
				cond = arg.indexOf("expend");
			} else {
				cond = Math.max(arg.indexOf("lend"), arg.indexOf("loopend"));
			}
			
			let fin = 0;
			
			if (cond > -1) {
			
				for (let j = 0; j < loopTimes; j++) {
					let nloopdat = cLoopData;
					
					let iterExpr;
					
					if (lmode == "exp") {
						iterExpr = ((j*loopMult)+(loopOff)).toString();
					} else {
						iterExpr = ((loopTimes-j-1)*(loopMult)+(loopOff)).toString();
					}
					
					if (nloopdat.includes("%LOOPITERH")) {
						nloopdat = nloopdat.replace(new RegExp("%LOOPITERH", "g"), conformHex(iterExpr));
					}
					if (nloopdat.includes("%LOOPITER")) {
						nloopdat = nloopdat.replace(new RegExp("%LOOPITER", "g"), iterExpr);
					}
					if (lmode == "exp") {
						let editorContent = FSEeditor.getValue();
						let editorContentLns = editorContent.split("\n");
						
						console.log(editorContentLns);
						
						fin += nloopdat.split("\n").length;
						
						editorContentLns.splice(expEndIndex+1+fin, 0, nloopdat.split("\n"));
						
						editorContentLns = editorContentLns.slice(editorContentLns.indexOf("expend")+1);
						
						if (j == loopTimes-1) {
						
							console.log(allAf);
						
							let temp = allBef;
							temp.push(editorContentLns.flat());
							temp.push(allAf.slice(1).flat());
							editorContentLns = temp.flat().join("\n");
						} else {
							editorContentLns = editorContentLns.flat().join("\n")
						}
						
						let fVal = editorContentLns;
						
						if (j == loopTimes-1) {
							fVal += "\n";
						}
						
						FSEeditor.setValue( fVal );
						
						console.log(fVal);
					} else {
						lines.splice(i+1, 0, nloopdat.split("\n"));
					}
				}
				lines = lines.flat();
				
				loopMult = 1;
				loopOff = 0;
				
				isFuncDef = false;
				cLoopData = "";
				
				loopTimes = 0;
				
			} else {
				cLoopData += arg.slice(0).join(" ")+"\n";
			}
			noliNewLineAre = true;
			
			FSEeditor.clearSelection();
		}
        
        if (!noliNewLineAre) {
            body += "\n";
        }
        noliNewLineAre = false;

        }

    }
	
	if (isFuncDef != false) {
		success = false;
		alert("Compiler is not in main state. A function or loop somewhere was not closed properly.");
		return;
	}
	
	if (activeLabel) {
		success = false;
		alert("Label not closed. Use 'end' or 'ret' to close a label.");
	}
	
	if (!endCalled) {
		body += "\nend\n";
	}
	
	if (noCompile) {
		return noCompString;
	}
	
	let k = String.raw`kek`.replace("kek", body);
	
	if ({objk: k.replace(/end/g, "").replace(/\n/g, "")}.objk.length == 0) {
		
		return "nothing to compile :(";
	}

    return header1+scriptText+header2+body+"\n"+footer+"\n\n";
}










function calcProgramBytes(text) {

    var lines = (text+"\n").split(/\n/);
    var bytesToOffset = 0;

    for(var i = 0; i < lines.length; i++) {
		var cline = lines[i];
        if (cline.charAt(0) != ";") {
        var arg = cline.split(" ");

        switch(arg[0].toLowerCase()) {
            case "applymovement":
            case "movement":
            case "mvmt":
            case "move":
            case "movenowait":
            case "movenowaitmovement":
            case "moven":
            case "moveno":
            case "movewait":
            case "movewithwait":
            case "movewithawait":
            case "movewithwaitmovement":
            case "movewithawaitmovement":
                bytesToOffset += arg.length;
                break;
            case "wrp":
            case "warp":
                bytesToOffset += 6;
                break;
            case "msgbox":
            case "msg":
            case "text":
            case "txt":
            case "filltext":
            case "domsgbox":
            case "message":
            case "messagebox":
                bytesToOffset += arg.slice(1).join(" ").length;
                break;
            case "givepokemon":
            case "givepoke":
            case "gp":
            case "addpokemon":
            case "pokemongive":
            case "poke":
            case "pokemon":
                if (text.includes("autoobtain false")) {
                    bytesToOffset += arg.length;
                }
                bytesToOffset += arg.length;
                break;
            default:
                bytesToOffset += arg.length+2;
                break;
        }
        }

    }

	return bytesToOffset;

}










var goff = document.getElementById("offset").value;
var whichGame = "rse";

var inbutton = document.getElementById("in");
var outbutton = document.getElementById("out");

outbutton.style.max_width = outbutton.style.width;
outbutton.style.max_height = outbutton.style.height;

if (localStorage["inputdata"] != "undefined" && localStorage["inputdata"] != undefined && localStorage["inputdata"] != null) {
    FSEeditor.setValue(localStorage["inputdata"], 0);
}




function convert() {
	resetAll();

    var inbutton = document.getElementById("in");
    var outbutton = document.getElementById("out");

    var rse = document.getElementById("rse").selected;
    var frlg = document.getElementById("frlg").selected;

    goff = document.getElementById("offset").value;
    var stat = document.getElementById("status");

    if (rse) {
        whichGame = "rse";
    } else {
        whichGame = "frlg";
    }
	
	FSEeditor.setValue( FSEeditor.getValue().replace(new RegExp("!se", "g"), "expstart").replace(new RegExp("!ee", "g"), "expend") );

    var intext = FSEeditor.getValue();
    localStorage["inputdata"] = intext;

    var res = getXSE(intext);

    if (success) {
        outbutton.innerHTML = res;

        outbutton.select();
        document.execCommand("copy");
        window.getSelection().removeAllRanges();
		
		FSEeditor.focus();
        
        stat.innerHTML = "Conversion successful. Output data copied to clipboard.";
    } else {
        stat.innerHTML = "Conversion unsuccessful. An alert box should have explained the error.";
        success = true;
    }
	
	outbutton.scrollTop = 0;

}






















        </script>
    </body>
</html>
