<!DOCTYPE HTML>
<html>
    <head>
        <title>FSE v1.0</title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="./tables.js" type="text/javascript"></script>
		<script id="sc" src="./scripts.js" type="text/javascript"></script>
    </head>
    <body style="font-family: 'Trebuchet MS'; overflow: hidden;">
        <p style="position: absolute; top: 0.7%; display: block;">Starting Offset:</p>
        <input id="offset" type="text" style="position: absolute; top: 6%;" value="0x800000"></input>
        <select style="position: absolute; top: 1px;">
            <option id="rse" value="1" selected>Ruby/Sapphire/Emerald</option>
            <option id="frlg" value="2">FireRed/LeafGreen</option>
        </select>
		<div style="position: absolute; left: 37%; top: 6.1%;">
			<label for="efont">Editor Font Size:&nbsp;</label>
			<input type="text" value="15" name="efont" id="ef" style="position: relative; left: 0.5%;"></input>
		</div>
		<div style="position: absolute; left: 37%; top: 10%;">
			<label for="ofont">Output Font Size:</label>
			<input type="text" value="14" name="ofont" id="of"></input>
		</div>
        <div style="position: absolute; left: 15%; top: 6.1%;">
        <label for="ts">Editor Theme:</label>
        <select name="ts" id="theme" style="position: relative;" onclick="changeMode();" defer>

        	<option>ambiance</option>
        	<option>chaos</option>
        	<option>chrome</option>
        	<option>clouds</option>
        	<option>clouds_midnight</option>
        	<option>cobalt</option>
        	<option>crimson_editor</option>
        	<option>dawn</option>
        	<option>dracula</option>
        	<option>dreamweaver</option>
        	<option>eclipse</option>
        	<option>github</option>
        	<option>gob</option>
        	<option>gruvbox</option>
        	<option>idle_fingers</option>
        	<option>iplastic</option>
        	<option>katzenmilch</option>
        	<option>kr_theme</option>
        	<option>kuroir</option>
        	<option>merbivore</option>
        	<option>merbivore_soft</option>
        	<option>mono_industrial</option>
        	<option>monokai</option>
        	<option>nord_dark</option>
        	<option>pastel_on_dark</option>
        	<option>solarized_dark</option>
        	<option>solarized_light</option>
        	<option>sqlserver</option>
        	<option>terminal</option>
        	<option>textmate</option>
        	<option>tomorrow</option>
        	<option>tomorrow_night</option>
        	<option>tomorrow_night_blue</option>
        	<option>tomorrow_night_bright</option>
        	<option>tomorrow_night_eighties</option>
        	<option selected>twilight</option>
        	<option>vibrant_ink</option>
        	<option>xcode</option>


        </select>
    	</div>
        <br>
        <br>
        <button id="convert_button" onclick="convert(); FSEeditor.clearSelection(); convert(); FSEeditor.clearSelection();" style="position: absolute; top: 11%; left: 12%;">Convert/Expand {Ctrl+Q}</button>
        <button id="help-button" onclick="launchHelp();" style="position: absolute; top: 11%;">Documentation/Help</button>
        <br>
        <br>
        
        <div id="in" style="position: absolute; top: 19%; right: 0%; left: .5%; bottom: 1%; margin-right: 55%;"></div>
		<p style="position: absolute; left: 0.6%; top: 13.65%;">FSE code (input)</p>
		<p style="position: absolute; left: 46%; top: 13.65%;">XSE code (output; automatically copied to clipboard)</p>
        <textarea id="out" cols="85" rows="33" readonly style="position: absolute; left: 46%; top: 18.95%; bottom: 1%; background-color: black; color: white; font-family: 'Trebuchet MS'; overflow-y: scroll; resize: none;"></textarea>
        <br>
		<div style="position: absolute; top: -2.5%; padding-top: 1%; left: 15%; line-height: 1;">
        <p id = "status">Welcome to FSE. This message will tell you whether or not a conversion was successful.</p>
		</div>
        <script src="./ace/ace.js" type="text/javascript" charset="utf-8"></script>
        <script defer>
		
		
		
		
		
String.prototype.replaceAt = function(index, replacement) {
    return this.substr(0, index+1) + replacement + this.substr(index + replacement.length);
}

var keysDown = [];
var keysUp = [];





function launchHelp() {

	window.open("https://github.com/ps4star/FSE/blob/master/ref.md");

}



var themeSel = document.getElementById("theme");

//Code editor stuff
var FSEeditor = ace.edit("in", {wrap: true});
FSEeditor.setTheme("ace/theme/xcode");
FSEeditor.session.setMode("ace/mode/assembly_x86");

FSEeditor.setValue("using namespace stdlib\n\nlf\n\n\n\nrel");

var csetfont = "20";
var offont = document.getElementById("out").style.fontSize;

document.addEventListener("keyup", function(e) {

    delete keysDown[keysDown.indexOf(e.key)];
	
	keysUp.push(e.key);
	
	

});

function updateFonts() {
	csetfont = document.getElementById("ef").value;
	offont = document.getElementById("of").value;
	
	document.getElementById("out").style.fontSize = offont+'px';
}

const noCompString = "Expansion statements successfully processed! Hit compile again to compile your code. Ctrl+Z to undo.";

$("#ef").on("change keyup paste", function(){
	updateFonts();
    FSEeditor.setOptions({fontSize: csetfont+"pt"});
});

$("#of").on("change keyup paste", function(){
    updateFonts();
});

if (localStorage["selection"] == "undefined") {
	localStorage["selection"] = "twilight";
}

let ops = [];
for (var i = 0; i < themeSel.options.length; i++) {
	ops.push(themeSel.options[i].text);
}
themeSel.selectedIndex = ops.indexOf(localStorage["selection"]);

function changeMode() {
	try {
		localStorage["selection"] = themeSel.options[themeSel.selectedIndex].text;
	} catch(e) {
		localStorage["selection"] = "twilight";
	}
	FSEeditor.setTheme("ace/theme/"+localStorage["selection"]);
	document.getElementById('in').style.fontSize=csetfont;
}


document.getElementById('in').style.fontSize=csetfont;

FSEeditor.focus();

FSEeditor.clearSelection();

var noliNewLineAre = false;


function determineType(data) {
    if (data.indexOf("#raw") > -1) {
        return "#raw";
    } else if (data.charAt(0)+data.charAt(1) == "= ") {
        return "text";
    }
}


function calcBytes(dataType, data) {
    if (dataType == "#raw") {
        return data.split("\n").length;
    } else if (dataType == "text") {
        return data.length-2;
    }
}





var currOff = 0;

function getOff() {
	let ret = "@"+autolabelname+currOff.toString();
	return ret;
}

function nextOff() {
	currOff++;
}

function changeOff(n) {
	currOff += n;
}


String.prototype.addOrg = function(data, specifyOrg) {

	if (typeof specifyOrg == 'undefined' || specifyOrg == 'undefined') {

		var toReturn = "#org "+getOff()+"\n"+data;
		
	} else {
	
		var toReturn = "#org "+specifyOrg+"\n"+data;
		
	}
    nextOff();
    goff = parseInt(goff, 16);
    goff += calcBytes(determineType(data), data);
    goff++; //Adds the extra byte to avoid overwriting terminators
    if (determineType(data) == "text") {
        goff++; //padding for strings. may not be necessary.
    }
    goff = "0x"+goff.toString(16).toUpperCase();
    return toReturn+"\n\n";
}


var cSpeed = "normal";

function isHex(n) {
	return (n.charAt(0)+n.charAt(1) == "0x");
}

function parseMoves(input) {

    if (whichGame == "rse") {
        var currentTable = rseMoveTable;
    } else {
        var currentTable = frlgmovetable;
    }

    var res = "";
	
	console.log(input);

    for(var i = 0; i < input.length; i++) {
	
		if (["up", "down", "left", "right"].indexOf(input[i]) == -1 && Object.keys(currentTable).indexOf(input[i]) == -1) {
	
			input[i] = input[i].replace("u", "up").replace("d", "down").replace("l", "left").replace("r", "right");
		
		}
		
		if (input[i] == "") {
			success = false;
			alert("Unnecessary space/empty string in applymovement move sequence.");
		}
		
		console.log(input[i]);
		
        if (["up", "down", "left", "right"].indexOf(input[i]) > -1 && Object.keys(currentTable).indexOf(input[i]) == -1) {
            input[i] += cSpeed;
        }
		if (isHex(input[i])) {
			res += "#raw "+input[i]+"\n";
		} else {
			res += "#raw "+currentTable[input[i]]+"\n";
		}
    }
    return res+"#raw 0xFE";

}

function pokeToID(poke) {

    return pokemontable[poke.toLowerCase()];

}

function itemToID(item) {

    return itemstable[item.toLowerCase()];

}

function attackToID(attack) {

	return attacktable[attack.toLowerCase()];
	
}


var success = true;


function toXSEhex(hexnum) {
    return "0x"+hexnum.toString(16).toUpperCase();
}

var constTable = {};

function deref(n) {

	if (Object.keys(constTable).indexOf(n) > -1) {
		return constTable[n];
	}
	return n;
	
}

function derefAllFromIndex(arr, index, keepsp) {

	keepsp = keepsp || 0;
	if (keepsp == 0) {
		keepsp = false;
	}

	arr = arr.flat();

	for (let v = index; v < arr.length; v++) {
	
		if (keepsp) {
		
			arr[v] = deref(arr[v]).replace(/&sp/gi, " ");
			
		} else {
	
			arr[v] = deref(arr[v]).split("&sp");
			
		}
	
	}
	
	return arr.flat();

}

function derefAllFromIndexFcall(arr, index) {

	for (let v = index; v < arr.length; v++) {
	
		arr[v] = deref(arr[v]);
	
	}
	
	return arr.flat();

}

function removeComments(arr) {

	let res = [];

	for (let e = 0; e < arr.length; e++) {
	
		if (arr[e].charAt(0) == ";") {
			break;
		}
		
		res.push(arr[e]);
	
	}
	
	return res;

}

function addFuncsFromCache() {
	
	let vals = JSON.parse(localStorage.func);
	
	let keys = Object.keys(vals);
	let values = Object.values(vals);
	
	for (let i = 0; i < keys.length; i++) {
	
		allScripts[keys[i]] = values[i];
	
	}
	
}

function loadCache() {

	if (typeof localStorage.func == 'undefined' || localStorage.func == "undefined" || !(localStorage.func.length > 0)) {
		
		localStorage.func = JSON.stringify({});
		
	} else {

		addFuncsFromCache();

	}
	
}

loadCache();

function clone(obj) { //copied from SO
    let k = Object.keys(obj);
	
	let res = {};
	
	for (let iter = 0; iter < k.length; iter++) {
	
		res[k[iter]] = obj[k[iter]];
		
	}
	
	return res;
		
}

const originalAllScripts = clone(allScripts); //for some reason Object.assign wasn't working here???

var cLab = "@start";
var endCalled = false;
var activeLabel = false;

var textBreakLimit = 30;
var originalTextBreakLimit = textBreakLimit;

var pageonbreak = false;

var autobreak = true;

var autolabelname = "offset";
var originalautolabelname = autolabelname;

var autosav = true;

function resetAll() {
	allScripts = clone(originalAllScripts);

	currOff = 0;
	constTable = {};
	cLab = "@start";
	
	lockReleaseText = "";
	
	endCalled = false;
	activeLabel = false;
	
	pageonbreak = false;
	textBreakLimit = originalTextBreakLimit;
	
	autobreak = true;
	
	autolabelname = originalautolabelname;
	
	autosav = true;
	
	FSEeditor.clearSelection();
}



function doLines(n) {

	if (!autobreak) {
		return n;
	}

	var chars = n.split("");
	var charID = 0;
	var hasBroken = false;
	var res = "";
	var doNotAddChar = false;
	
	var lastSpace = 0;
	
	var breaks = 0;
	
	let kek = "meme meme2";
	
	for (let iter = 0; iter < chars.length; iter++) {
	
		if (chars[iter] == " ") {
			lastSpace = iter+breaks;
		}
	
		if (charID >= textBreakLimit && (!hasBroken && chars[iter] == " ")) {
			res = res.substring(0, lastSpace) + "\\n" + res.substring(lastSpace, res.length);
			hasBroken = true;
			charID = -1;
			doNotAddChar = true;
			breaks++;
		} else if (charID >= textBreakLimit && chars[iter] == " ") {
			if (pageonbreak) {
				if (breaks % 2 != 0) {
					res = res.substring(0, lastSpace) + "\\p" + res.substring(lastSpace, res.length)
				} else {
					res = res.substring(0, lastSpace) + "\\n" + res.substring(lastSpace, res.length)
				}
			} else {
				res = res.substring(0, lastSpace) + "\\l" + res.substring(lastSpace, res.length)
			}
			charID = -1;
			doNotAddChar = true;
			breaks++;
		}
		
		if (!doNotAddChar) {
		
			res += chars[iter];
			
			if (["\\n", "\\l", "\\p"].indexOf(chars[iter]) > -1) {
				charID = -1;
				breaks++;
			}
			
		} else {
		
			doNotAddChar = false;
		
		}
	
		charID++;
	
	}
	
	if (["\n", "\l", "\p"].indexOf(res.charAt(res.length-1)) > -1 || res.charAt(res.length-1) == " ") {
		res = res.substring(0, res.length-2);
	}
	
	return res;

}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

var specialArgs = ["A", "P", "I"];

function getHighestArgFromTemplate(template) {

	var lns = template.split('\n');
	var cHighest = -1;
	
	for (let i = 0; i < lns.length; i++) {
	
		lns[i] = lns[i].toLowerCase();
	
		while (lns[i].includes("%arg")) {
			if (specialArgs.indexOf(lns[i].charAt(lns[i].length-1)) > -1) {
				lns[i] = lns[i].substring(0, (lns[i].length+1) - specialArgs[specialArgs.indexOf(lns[i].charAt(lns[i].length-1))].length);
			}
			let argInt = lns[i].substring(lns[i].indexOf("%arg")+4, lns[i].length).split(" ")[0];
			if (parseInt(argInt) > cHighest) {
				cHighest = parseInt(argInt);
			}
			
			lns[i] = lns[i].replace("%arg"+parseInt(argInt).toString(), "");
			if (parseInt(argInt) == 0) {
				success = false;
				alert("Arg 0 does not exist.");
				return;
			}
		}
	
	}
	
	return cHighest;

}

getHighestArgFromTemplate(`
msg %ARG1 0x4
msg %ARG2 0x4
msg %ARG3 0x4
`); //holy shit it actually worked first try, no debugging, wtf???

//converts templates to strings
for (let f = 0; f < Object.keys(allScripts).length; f++) {
	
	let keys = Object.keys(allScripts);
	
	allScripts[keys[f]] = allScripts[keys[f]];
	
}

var numsAsStrings = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

function isNonHexInt(n) {

	let chars = n.split("");
	
	if (parseInt(n) == NaN) {
		return false;
	}
	
	for (let i = 0; i < chars.length; i++) {
		
		if (numsAsStrings.indexOf(chars[i]) == -1) {
			return false;
		}
		
	}
	
	return true;

}

function prepCase(n) {
	let nc = n.split("");
	
	for (let h = 0; h < nc.length; h++) {
		
		if (h > 1) {
			nc[h] = nc[h].toUpperCase();
		}
		
	}
	
	return nc.join("");
}

function conformHex(n, tableRef, decTable) {

	if (isHex(n)) {
		return prepCase(n);
	} else if (isNonHexInt(n)) {
		//is decimal int
		return prepCase(toXSEhex(parseInt(n)));
	} else {
		if (tableRef == undefined) {
			return false;
		}
		if (decTable) {
			return prepCase(toXSEhex(parseInt(tableRef[n])));
		}
		return prepCase(tableRef[n]); //must be string
	}

}

function repArgs(data, args, arg, cHighest) {

	var res = data;

	for (let m = 1; m <= args; m++) {
	
		res = res.replace(new RegExp("%arg"+m+"p", "gi"), conformHex(arg[m+1], pokemontable, true));
		
		res = res.replace(new RegExp("%arg"+m+"i", "gi"), conformHex(arg[m+1], itemstable, true));
		
		res = res.replace(new RegExp("%arg"+m+"a", "gi"), conformHex(arg[m+1], attacktable, true));
		
		res = res.replace(new RegExp("%arg"+m+"h", "gi"), conformHex(arg[m+1]));
		
		res = res.replace(new RegExp("%arg"+m, "gi"), arg[m+1]);
		
	}
	
	return res.replace(/\&sp/g, " ").split(/\n/g);

}

String.prototype.lstrip = function() 
{
	return String(this).replace(/^@+|@+$/g, '');
};

//expand functions o_o
	

String.prototype.swapChars = function(arg1, arg2) {

	let res = this;

	for (let c = 0; c < res.length; c++) {
		
		if (res.charAt(c) == arg1) {
			res = res.substring(0, c) + arg2 + res.substring(c+1, res.length);
		} else if (res.charAt(c) == arg2) {
			res = res.substring(0, c) + arg1 + res.substring(c+1, res.length);
		}
		
	}
	
	return res;

}

window.onload = function() {
	changeMode();
	FSEeditor.setOptions({fontSize: "15pt"});
	FSEeditor.clearSelection();
	
}

document.addEventListener("keydown", function(e) {

    keysDown.push(e.key);

    if ( keysDown.indexOf("Control") > -1 && keysDown.indexOf("q") > -1 || ( keysDown.indexOf("Control") > -1 && keysDown.indexOf(";") > -1) ) {
        convert();
		keysDown = [];
		FSEeditor.clearSelection();
    }
	
	keysUp = [];

});

function conformSyntax(argument, times) {

	times = times || 2;

	let arg = argument.slice(times);

	let mode = " ";
	
	for (let n = 0; n < arg.length; n++) {
		if (arg[n].includes("|")) {
			mode = ","
			break;
		} else if (arg[n].includes(" ")) {
			arg[n] = arg[n].replace(new RegExp(" ", "g"), "&sp");
		} else {
			mode = " ";
		}
	}
	
	if (mode == " ") {
		let res = arg;
		for (let f = 0; f < times; f++) {
			res.unshift(argument[(times-f-1)]);
		}
		return res;
	} else {
		let res = arg.join(" ").split("|");
		for (let f = 0; f < times; f++) {
			res.unshift(argument[(times-f-1)]);
		}
		return res.flat();
	}

}

function repComs(arg, s) {

	let res = arg;
	
	for (let u = s || 2; u < arg.length; u++) {
		
		res[u] = res[u].replace(new RegExp("&bar", "gi"), "|");
		
	}
	
	return res;

}

function globalBarRep(arr) {

	let lines = arr;
	
	for (let g = 0; g < lines.length; g++) {
	
		let lnspace = lines[g].split("");
		
		for (let h = 0; h < lnspace.length; h++) {
		
			if (lnspace[h-1]+lnspace[h]+lnspace[h+1] == " | ") {
		
				lnspace[h-1] = "";
				lnspace[h+1] = "";
				
			}
			
		}
		
		lines[g] = lnspace.join("");
		
	}
	
	return lines;
	
}

function getXSE(text) {
    let lines = (text.replace(new RegExp("    ", "g"), "").replace(new RegExp("\t", "g"), "").replace(new RegExp("\r\n", "g"), "\n").replace(new RegExp("%PL", "gi"), "[player]").replace(new RegExp("%RI", "gi"), "[rival]")+"\n").replace(new RegExp("%lr", "gi"), "LASTRESULT").split(/\n/);
	
	lines = globalBarRep(lines);
	
	let actualLength = lines.length;
    let header1 = "#dynamic "+goff;
	let scriptText = "\n";
	let header2 = "\n#org @main\n\n";
    let body = "";
    let footer = "";
	
	let endsNeeded = 1;
	
	let cEndingText = "\n\nend";
	
	let globalLine = 0;
	
	let isFuncDef = false;
	let funcName = "";
	
	let oldFuncValue = isFuncDef;
	
	let noCompile = false;
	
	let allBef = [];
	let lmode = "loop";
	
	let loopTimes = 0;
	
	let cLoopData = "";
	
	let loopOff = 0;
	let loopMult = 1;
	
	let indOfStart = 0;
	let indOfEnd = 0;
	
	let tableName = "!undef";

	//console.log(goff)
    for(var i = 0; i < lines.length; i++) {
        var cline = lines[i];

        if (cline.charAt(0) != ";") {
		
        var arg = cline.split(" ");
		
		arg = removeComments(arg);
		
		for (let b = 0; b < arg.length; b++) {
			if (arg[b].includes("\;")) {
				arg[b] = arg[b].split("\\;").join(";");
			}
			if (b > 0 && arg[b] == "") {
				delete arg[b];
			}
		}
		
		let originalArgs = arg;
		
		if (isFuncDef == false) {

        switch(arg[0].toLowerCase()) {
			case "&comstart":
				oldFuncValue = isFuncDef;
				isFuncDef = "com";
				break;
			case "$table":
			case "$tabstart":
			case "$tablestart":
			
				noliNewLineAre = true;
			
				arg[1] = "@"+arg[1].lstrip("@");
			
				if (arg.length != 2) {
					success = false;
					alert("Too few or too many arguments provided for "+arg[0]+".");
					return;
				}
				
				isFuncDef = "tab";
				
				tableName = arg[1];
				
				constTable[arg[1]] = {};
				
				break;
			case "$funcstart":
				if (arg.length < 2 || arg[1].length < 1) {
					success = false;
					alert("$funcstart requires a func name. Exception on line.");
					return;
				}
				noliNewLineAre = true;
				oldFuncValue = isFuncDef;
				isFuncDef = true;
				funcName = arg[1];
				allScripts[funcName] = ``;
				
				localStorage.func[funcName] = ``;
				
				break;
			case "compile":
				arg = derefAllFromIndex(arg, 1);
				
				alert(getXSE(arg.slice(1).join(" ")));
				
				break;
			case "setlabelname":
				arg = derefAllFromIndex(arg, 1);
				
				autolabelname = arg[1];
				
				break;
			case "compare":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "compare "+arg[1]+" "+arg[2];
			
				break;
			case "if":
			
				console.log(arg);
			
				if (arg.length < 4) {
					success = false;
					alert("if requires 3 arguments.");
					return;
				}
				
				if (arg[1].toLowerCase() == "last") {
					arg[1] = "LASTRESULT";
				}
				
				if (arg.slice(1).join(" ").includes("|")) {
					arg = conformSyntax(arg);
					arg = arg.join(" ").split(" ");
					
					body += "compare "+arg[1]+" "+conformHex(arg[3])+"\n";
					arg.splice(1, 1);
					arg.splice(2, 1);
					
					
					
					console.log(arg);
				}
			
				arg = derefAllFromIndex(arg, 1);
			
				arg[1] = conformHex(arg[1], {"<": "0x0", "=": "0x1", "==" : "0x1", ">": "0x2", "<=" : "0x3", ">=" : "0x4", "!=": "0x5"});
				
				body += "if "+arg[1]+" "+arg[2]+" "+arg[3];
			
				break;
			case "copyvar":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "copyvar "+arg[1]+" "+arg[2];
			
				break;
			case "copyvarifnotzero":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "copyvarifnotzero "+arg[1]+" "+arg[2];
			
				break;
			case "checkitem":
			
				if (arg.length < 3) {
					success = false;
					alert("checkitem requires 2 arguments.");
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				arg[1] = conformHex(arg[1], itemstable, true);
				
				arg[2] = conformHex(arg[2]);
				
				body += "checkitem "+arg[1]+" "+arg[2];
			
				break;
			case "removeitem":
			
				if (arg.length < 3) {
					success = false;
					alert("removeitem requires 2 arguments.");
					return;
				}
				
				arg = derefAllFromIndex(arg, 1);
				
				arg[1] = conformHex(arg[1], itemstable, true);
				
				arg[2] = conformHex(arg[2]);
				
				body += "removeitem "+arg[1]+" "+arg[2];
			
				break;
			case "givemoney":
			
				if (arg.length > 2) {
					alert("givemoney in FSE only takes 1 arg: the money amount.");
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
			
				body += "givemoney "+conformHex(arg[1])+" 0x0";
			
				break;
			case "takemoney":
			
				if (arg.length > 2) {
					alert("takemoney in FSE only takes 1 arg: the money amount.");
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
			
				body += "takemoney "+conformHex(arg[1])+" 0x0";
			
				break;
			case "showmoney":
			
				if (arg.length < 3) {
					alert("showmoney requires 2 arguments.");
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "showmoney "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "hidemoney":
			
				if (arg.length < 3) {
					alert("hidemoney requires 2 arguments.");
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "hidemoney "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "updatemoney":
			
				if (arg.length < 3) {
					alert("updatemoney requires 2 arguments.");
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "updatemoney "+conformHex(arg[1])+" "+conformHex(arg[2])+" 0x0";
			
				break;
			case "addvar":
			
				if (arg.length < 3) {
					alert("addvar requires 2 arguments.");
					success = false;
					return;
				}
				
				arg = derefAllFromIndex(arg, 1);
				
				body += "addvar "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "subvar":
			
				if (arg.length < 3) {
					alert("subvar requires 2 arguments.");
					success = false;
					return;
				}
				
				arg = derefAllFromIndex(arg, 1);
				
				body += "subvar "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "setvar":
			
				if (arg.length < 3) {
					alert("setvar requires 2 arguments.");
					success = false;
					return;
				}
				
				arg = derefAllFromIndex(arg, 1);
				
				body += "setvar "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "showpokepic":
			
				if (arg.length < 4) {
					alert('showpokepic requires 3 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
			
				body += "showpokepic "+conformHex(arg[1], pokemontable, true)+" "+conformHex(arg[2])+" "+conformHex(arg[3]);
			
				break;
			case "setdooropened":
			
				if (arg.length < 3) {
					alert('setdooropened requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "setdooropened "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "setdoorclosed":
			
				if (arg.length < 3) {
					alert('setdoorclosed requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "setdoorclosed "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "opendoor":
			
				if (arg.length < 3) {
					alert('opendoor requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "setdooropened "+conformHex(arg[1])+" "+conformHex(arg[2]);
				body += "\ndoorchange";
			
				break;
			case "closedoor":
			
				if (arg.length < 3) {
					alert('closedoor requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "setdoorclosed "+conformHex(arg[1])+" "+conformHex(arg[2]);
				body += "\ndoorchange";
			
				break;
			case "checkcoins":
			
				if (arg.length < 2) {
					alert('checkcoins requires 1 argument.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "checkcoins "+conformHex(arg[1]);
			
				break;
			case "givecoins":
			
				if (arg.length < 2) {
					alert('givecoins requires 1 argument.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "givecoins "+conformHex(arg[1]);
			
				break;
			case "removecoins":
			
				if (arg.length < 2) {
					alert('removecoins requires 1 argument.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "removecoins "+conformHex(arg[1]);
			
				break;
			case "showcoins":
			
				if (arg.length < 3) {
					alert('showcoins requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "showcoins "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "hidecoins":
			
				if (arg.length < 3) {
					alert('updatecoins requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "hidecoins "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "updatecoins":
			
				if (arg.length < 3) {
					alert('updatecoins requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "updatecoins "+conformHex(arg[1])+" "+conformHex(arg[2]);
				
				break;
			case "yesnobox":
			
				if (arg.length < 3) {
					alert('yesnobox requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "yesnobox "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "getplayerpos":
			
				if (arg.length < 3) {
					alert('getplayerpos requires 2 arguments.');
					success = false;
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "getplayerpos "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "compseqe":
			case "compareseqexplicit":
			case "compsequenceexplicit":
			case "compsequenceexplicit":
				let startOfArgSeqe = 2;
				
				arg = derefAllFromIndex(arg, 1);
				
				if (arg.length < 3) {
					success = false;
					alert("compseqexplicit requires at least 2 arguments.");
					return;
				}
				
				if (!isHex(arg[1])) {
					success = false;
					alert("compseqexplicit arg 1 is not hex. Exception on line.");
					return;
				}
				
				for (startOfArgSeqe; startOfArgSeqe < arg.length; startOfArgSeqe += 2) {
				
					body += "compare "+arg[1]+" "+conformHex(arg[startOfArgSeqe].toString());
					body += "\nif 0x1 goto "+arg[startOfArgSeqe+1]+"\n";
				
				}
				
				noliNewLineAre = true;
			
				break;
			case "prepmsg":
			case "preparemsg":
			case "prepmsgnowait":
			case "preparemsgnowait":
				arg = derefAllFromIndex(arg, 1);
				
				body += "preparemsg "+conformHex(arg[1]);
				
				if (!arg[0].toLowerCase().includes("nowait")) {
					body += "\nwaitmsg";
				}
				
				break;
			case "compseq":
			case "compareseq":
			case "compsequence":
			case "comparesequence":
				let startOfArgSeq = 2;
				let sValue = 0;
				
				arg = derefAllFromIndex(arg, 1);
				
				console.log("iscomp");
				
				if (arg.length < 3) {
					success = false;
					alert("compseq requires at least 2 arguments.");
					return;
				}
				
				if (!isHex(arg[1]) && arg[1].toLowerCase() != "lastresult") {
					success = false;
					alert("compseq arg 1 is not hex. Exception on line.");
					return;
				}
				
				for (startOfArgSeq; startOfArgSeq < arg.length; sValue++, startOfArgSeq++) {
				
					body += "compare "+arg[1]+" "+conformHex(sValue.toString());
					body += "\nif 0x1 goto "+arg[startOfArgSeq]+"\n";
				
				}
				
				noliNewLineAre = true;
				
				break;
			case "setmaptile":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "setmaptile "+conformHex(arg[1])+" "+conformHex(arg[2])+" "+conformHex(arg[3])+" "+conformHex(arg[4]);
			
				break;
			case "doublebattle":
			case "gymbattle":
			case "trainerbattle":
			
				arg = conformSyntax(arg); //conforms comma to space
				
				arg = derefAllFromIndex(arg, 1, true);
				
				if (arg.length != 4) {
					success = false;
					alert("trainer/double/gymbattle all require 3 arguments. Provided: "+arg.length+".");
					return;
				}
				
				if (autobreak) {
					arg[2] = doLines(arg[2]);
					arg[3] = doLines(arg[3]);
				}
				
				let id = 0;
				id = (arg[0].toLowerCase() == "gymbattle") ? 1 : id;
				id = (arg[0].toLowerCase() == "doublebattle") ? 2 : id;
				
				let firstoff = getOff();
				nextOff();
				let secondoff = getOff();
				
				body += "trainerbattle "+conformHex(id.toString())+" "+arg[1]+" 0x0 "+firstoff+" "+secondoff;
				
				changeOff(-1);
				
				footer += footer.addOrg("= "+arg[2]);
				footer += footer.addOrg("= "+arg[3]);
				
				break;
			case "applymovementreverse":
			case "applymovementnowaitreverse":
			case "movereverse":
			case "mover":
			case "movenowaitreverse":
            case "applymovement":
            case "move":
			case "applymovementnowait":
            case "movenowait":
				if (arg.length < 3 || arg[arg.length-1] == "") {
					success = false;
					alert("move commands require at least 2 arguments.");
					return;
				}
				arg = derefAllFromIndex(arg, 1);
				if (arg[0].toLowerCase().includes("r")) {
				
					console.log(arg);
				
					arg = arg.reverse();
					arg.unshift(arg.pop());
					arg.unshift(arg.pop());
					let k = arg[1];
					arg[1] = arg[0];
					arg[0] = k;
					
					for (let thisa = 2; thisa < arg.length; thisa++) {
						
						switch (arg[thisa].toLowerCase()) {
							case "up":
								arg[thisa] = "down";
								break;
							case "u":
								arg[thisa] = "down";
								break;
							case "left":
								arg[thisa] = "right";
								break;
							case "l":
								arg[thisa] = "right";
								break;
							case "r":
								arg[thisa] = "left";
								break;
							case "right":
								arg[thisa] = "left";
								break;
							case "down":
								arg[thisa] = "up";
								break;
							case "d":
								arg[thisa] = "up";
								break;
								
						}
						
					}
				}
                body += "applymovement "+arg[1]+" "+getOff();

                if (!(arg[0].toLowerCase().includes("nowait"))) {
                    body += "\nwaitmovement 0x0";
                }

                footer += footer.addOrg(parseMoves(arg.slice(2)));
                break;
			case "pokemart":
			
				if (arg.length == 1) {
					success = false;
					alert("pokemart requires at least 1 argument.");
					return;
				}
			
				arg = derefAllFromIndex(arg, 1);
				let orgStatement = "";
				
				for (let j = 1; j < arg.length; j++) {
					
					orgStatement += "#raw word "+conformHex(arg[j], itemstable, true)+"\n";
					
				}
				
				orgStatement += "#raw word 0x0";
				
				console.log(arg);
				console.log(orgStatement);
				
				body += "pokemart "+getOff();
				
				footer += footer.addOrg( orgStatement );
			
				break;
			case "bufferattack":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferattack "+arg[1]+" "+conformHex(arg[2], attacktable);
				
				break;
			case "bufferpokemon":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferpokemon "+arg[1]+" "+conformHex(arg[2], pokemontable, true);
				
				break;
			case "bufferfirstpokemon":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferfirstpokemon "+arg[1];
				
				break;
			case "bufferitem":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "bufferitem "+arg[1]+" "+conformHex(arg[2], itemstable, true);
				
				break;
			case "buffernumber":
				arg = arg.join("\n").toLowerCase().split("\n");
				
				arg[1] = arg[1].replace(/\[buffer/g, "").replace(/\]/g, "");
				
				arg[1] = conformHex((parseInt(arg[1])-1).toString());
				
				body += "buffernumber "+arg[1]+" "+conformHex(arg[2]);
				
				break;
			case "func":
			case "fcall":
			
				arg = conformSyntax(arg); //conforms to space mode
				
				arg = derefAllFromIndex(arg);
				
				console.log(arg);
			
				try {
			
					var reference = eval('allScripts.'+arg[1]);
					
				} catch(e) {
				

					
					success = false;
					alert("Specified function not found. Exception on line.");
					return;
				
				}
			
				if (arg.length < 2) {
					success = false;
					alert("fcall requires at least 1 argument. Exception on line.");
					return;
				}
				
				if (reference == "undefined" || typeof reference == "undefined") {
					success = false;
					alert("Function "+arg[1]+" not defined. Edit scripts.js to create a definition.");
					return;
				}
				
				let thisHighestArg = getHighestArgFromTemplate(reference);
				
				if (arg.length-2 < thisHighestArg) {
					success = false;
					alert("The function definition requires more arguments than actual arguments provided in fcall. Exception on line.");
					return;
				}
				
				if (arg.length-2 > thisHighestArg && false) {
					success = false;
					alert("Too many args in function "+arg[1]+". Remember to use bar syntax (|) for passing multi-space strings as func args.");
					return;
				}
				
				if (arg.length > 2 && thisHighestArg == 1) {
					arg[2] = arg.slice(2).join(" ");
				}
				
				let finalVal = repArgs(reference, thisHighestArg, arg, thisHighestArg);
				
				lines.splice(i+1, 0, finalVal);
				lines = lines.flat();
				
				noliNewLineAre = true;
				
				break;
			case "pause":
				arg = derefAllFromIndex(arg, 1);
				
				if (arg.length > 2 || arg.length == 1) {
					alert("pause takes 1 argument (times). Either too many or too few args provided.");
					success = false;
					return;
				}
				
				if (isHex(arg[1])) {
					
					body += "pause "+arg[1];
					
				} else {
				
					body += "pause "+toXSEhex(Math.round(parseInt(arg[1])/1000*32));
					
				}
				
				break;
			case "expstart":
			case "lstart":
			case "loopstart":
			case "loop":
				arg = derefAllFromIndex(arg, 1);
				
				if (arg.length >= 3) {
					loopOff = parseInt(arg[2]);
				}
				
				if (arg.length == 4) {
					loopMult = parseInt(arg[3]);
				}
				
				if (arg[0].toLowerCase() == "expstart") {
					
					if (arg.length > 4) {
						success = false;
						alert("!se can take at most 3 arguments. More than 3 provided.");
						return;
					}
					
					let fsecont = FSEeditor.getValue();
					let fselines = fsecont.split("\n");
					//console.log(fselines);
					
					let indexOfStart = 0;
					let indexOfEnd = 0;
					for (let r = 0; r < fselines.length; r++) {
						if (fselines[r].split(" ")[0] == "expstart") {
							indexOfStart = r;
						}
						if (fselines[r] == "expend") {
							indexOfEnd = r;
							break;
						}
					}
					
					var res = fselines.slice(0, indexOfStart);
					res.push(fselines.slice(indexOfEnd));
					
					res = res.flat();
					
					var splicePoint = res.indexOf("expend");
					
					res[splicePoint] = "";
				
					noCompile = true;
					
					lmode = "exp";
					
					var expStartIndex = i;
					var expEndIndex = lines.slice(i).indexOf("expend")+i;
					
				} else {
					lmode = "loop";
				}
				
				cLoopData = "";
				
				if (arg.length < 2 || arg[1].length < 1) {
					success = false;
					if (noCompile) {
						alert("Expansion statements require a times argument (like \"expstart 5\" loops the statement 5 times). They are essentially loops, after all.");
					} else {
						alert("loop requires a times argument.");
					}
					return;
				}
				
				loopTimes = parseInt(arg[1]);
				
				isFuncDef = "loop";
				
				noliNewLineAre = true;
				
				break;
			case "loopend":
			case "lend":
			case "expend":
				break;
			case "setbreaklimit":
			case "breaklimit":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				textBreakLimit = parseInt(arg[1]);
				
				noliNewLineAre = true;
				
				break;
			case "pageonbreak":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				
				pageonbreak = ( arg[1] == 'true' );
				
				noliNewLineAre = true;
				
				break;
			case "goto":
				arg = derefAllFromIndex(arg, 1);
				
				body += "goto "+arg.slice(1).join(" ");
				
				break;
			case "l":
			case "lock":
				body += "lock";
				break;
			case "lf":
			case "lockface":
			case "lockfaceplayer":
				body += "lock\nfaceplayer";
				break;
			case "face":
			case "faceplayer":
				body += "faceplayer";
				break;
			case "rel":
			case "release":
				if (cLab != "@start" && !activeLabel) {
					success = false;
					alert("Release statements must either be in @start or another label. This release is not in any label. Exception on line.");
				}
				body += "release";
				break;
			case "@":
			case "lbl":
			case "org":
			case "label":
				arg[1] = "@"+arg[1].lstrip("@");
				activeLabel = true;
				endsNeeded++;
				if (cLab == "@start" && endsNeeded == 2) {
					body += "\nend\n";
				}
				cLab = arg[1];
				if (arg[1].charAt(0) != "@") {
					success = false;
					alert("Labels must start with @. Error on line "+(globalLine+1)+".");
				}
				if ((arg[1].match(/@/g) || []).length > 1) {
					success = false;
					alert("Labels must start with @, but cannot contain @ elsewhere, only the first char. Pls fix. Exception on line.");
					return;
				}
				body += "\n#org "+originalArgs[1]+"\n";
				console.log(arg);
				break;
			case "ret":
			case "return":
				if (!activeLabel) {
					success = false;
					alert("Ret used on line, but no corresponding lbl.");
					return;
				}
				activeLabel = false;
				endsNeeded--;
				endCalled = true;
				body += "\nreturn\n";
				break;
			case "end":
				activeLabel = false;
				endCalled = true;
				body += "\nend";
				endsNeeded--;
				break;
			case "const":
			case "define":
			case "sconst":
				if (arg[2] == "=") {
					arg.splice(2, 1);
				}
				if (arg.length < 3) {
					success = false;
					alert("Consts require a name and value (2 params). Params given: "+(globalLine+1)+".");
				}
				if (["@"].indexOf(arg[1].charAt(0)) == -1 || Object.keys(constTable).indexOf(arg[1]) > -1) {
					success = false;
					alert("Const on line either does not start with const identifier (%) or has already been defined.");
				}
				
				let constVal = arg.slice(2).join(" ");
				let constLn = 0;
				
				let oldConstVal = constVal;
				
				if (constVal.includes(" ")) {
					constLn = constVal.split(" ").length;
				} else {
					constLn = constVal.length;
				}
				
				constVal = constVal.replace(/&sp/g, "&lsp");
				constVal = constVal.split(" ").join("&sp");
				
				constTable[arg[1]] = constVal;
				
				constTable["getln"+arg[1]] = constLn.toString();
				constTable["getlnreal"+arg[1]] = oldConstVal.length.toString();
				
				if (oldConstVal.includes(" ")) {
					let cvSpaces = oldConstVal.split(" ");
					for (let u = 0; u < cvSpaces.length; u++) {
						constTable["indexat"+u.toString()+arg[1]] = cvSpaces[u];
					}
				}
				
				noliNewLineAre = true;
				break;
			case "setflag":
			case "sf":
				arg = derefAllFromIndex(arg, 1);
				
				body += "setflag "+arg[1];
				
				break;
			case "clearflag":
			case "cf":
			case "resetflag":
				arg = derefAllFromIndex(arg, 1);
				
				body += "clearflag "+arg[1];				
				
				break;
            case "warp":
			case "warpto":
				arg = derefAllFromIndex(arg, 1);
                body += "warp 0x"+parseInt(arg[1], 16)+" 0x"+parseInt(arg[2], 16)+" 0x"+parseInt(arg[3], 16)+" 0x0 0x0";
                break;
			case "setautobreak":
			case "autobreak":
				arg = derefAllFromIndex(arg, 1);
				
				autobreak = ( arg[1] == 'true' );
				
				break;
            case "setspeed":
			case "setmovespeed":
				arg = derefAllFromIndex(arg, 1);
                if (arg[1]+arg[2] == "veryslow" || arg[1] == "veryslow" || arg[1] == "vslow") {
                    if (whichGame == "rse") {
                        alert("The 'very slow' speed did not exist in R/S/E. Please change the game to FR/LG if you're working with that game, or adjust the speed to 'slow', 'normal', 'fast', 'faster', or 'fastest' if you're working with R/S/E.");
                        success = false;
                    } else {
                        cSpeed = "veryslow";
                    }
                } else {
					if (arg[1]+arg[2] == "veryslow") {
						cSpeed = "veryslow";
					} else {
						cSpeed = arg[1];
					}
                }
                noliNewLineAre = true;
                break;
			case "using":
				arg.shift();
				noliNewLineAre = true;
			case "writetop":
			case "loadlib":
			case "surface":
			case "namespace":
			
				noliNewLineAre = true;
				
				let ref;
				let asKeys;
			
				if (arg.length < 2) {
					success = false;
					alert("namespace requires 1 argument. Exception on line.");
					return;
				}
				
				ref = eval("allScripts."+arg[1]);
				
				if (ref == "undefined" || typeof ref == "undefined") {
					
					success = false;
					alert("No such lib "+arg[1]+" exists.");
					return;
					
				}
				
				asKeys = Object.keys(ref);
				
				for (let thisName = 0; thisName < asKeys.length; thisName++) {
					
					allScripts[asKeys[thisName]] = ref[asKeys[thisName]];
					
				}
			
				break;
			case "random":
				
				arg = derefAllFromIndex(arg, 1);
				
				arg[1] = conformHex(arg[1]);
				
				body += "random "+arg[1];
			
				break;
			case "special2":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "special2 "+conformHex(arg[1])+" "+conformHex(arg[2]);
			
				break;
			case "hidesprite":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "hidesprite "+conformHex(arg[1]);
			
				break;
			case "showsprite":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "showsprite "+conformHex(arg[1]);
			
				break;
			case "setweather":
			
				arg = derefAllFromIndex(arg, 1);
			
				body += "setweather "+conformHex(arg[1]);
				
				break;
			case "weather":
			
				arg = derefAllFromIndex(arg, 1);
				
				body += "setweather "+conformHex(arg[1]);
				body += "\ndoweather";
			
				break;
            case "msgbox":
            case "msg":
				if (arg.length < 3) {
					success = false;
					alert("msgbox requires 2 arguments, "+(globalLine+1)+" provided.");
				}
				arg = derefAllFromIndex(arg, 1);
				
				for (let g = 1; g < arg.length-1; g++) {
					if (arg[g].indexOf(String.raw`\n`) > -1 && arg[g].indexOf(String.raw`\\n`) == -1) {
						success = false;
						alert("Use \\\\n not \\n. Exception on line.");
						return;
					}
					arg[g] = arg[g].replace("\\\\n", "\\n");
				}
				
				if (!(isHex(arg[arg.length-1]))) {
					if (arg[arg.length-1].substring(0, 4) != "MSG_") {
						success = false;
						alert("last argument of msgbox is not a msgbox type (hex int). This error could also be caused by failing to escape \\n in an externally-called msgbox. Use \\\\n for external strings, not \\n.");
					}
				}
            	let txtOff = getOff();
                body += "msgbox "+txtOff+" "+arg.slice(-1)[0];
				if (autobreak) {
					footer += footer.addOrg("= "+doLines(arg.slice(1, -1).join(" "))); //Adds our text data.
				} else {
					footer += footer.addOrg("= "+arg.slice(1, -1).join(" "));
				}
                break;
			case "xse":
			case "xsed":
			case "raw":
				if (arg[0].toLowerCase() == "xsed") {
					arg = derefAllFromIndex(arg, 1);
				}
				
				body += arg.slice(1).join(" ");
				
				break;
			case "giveitem":
			case "item":
				arg = derefAllFromIndex(arg, 1);
				
				arg[1] = conformHex(arg[1], itemstable, true);
				
				arg[2] = conformHex(arg[2]);
				
				body += "giveitem "+arg[1]+" "+arg[2]+" MSG_OBTAIN";
				
				break;
			case "fadein":
			case "fadeinb":
				body += "fadescreen 0x0";
				break;
			case "fadeout":
			case "fadeoutb":
				body += "fadescreen 0x1";
				break;
			case "fadeinw":
				body += "fadescreen 0x2";
				break;
			case "fadeoutw":
				body += "fadescreen 0x3";
				break;
			case "cry":
				arg[1] = arg[1].toLowerCase();
				arg[1] = conformHex(arg[1], pokemontable, true);
				
				body += "cry "+arg[1]+" 0x0";
				
				break;
			case "giveegg":
			
				if (arg.length == 1 || arg.length > 2) {
					success = false;
					alert("Too many or too few giveegg arguments provided.");
					return;
				}
				
				arg = derefAllFromIndex(arg, 1);
				
				body += "giveegg "+conformHex(arg[1], pokemontable, true);
			
				break;
			case "textcolor":
			
				if (arg.length == 1 || arg.length > 2) {
					success = false;
					alert("Too many or too few textcolor arguments provided.");
					return;
				}
			
				arg[1] = arg[1].toLowerCase();
				
				arg[1] = conformHex(arg[1], {"blue": "0x00", "red" : "0x01", "black" : "0x02"});
				
				body += "textcolor "+arg[1];
				
				break;
			case "wildbattle":
            case "givepokemon":
            case "pokemon":
				arg = derefAllFromIndex(arg, 1);
				arg[1] = arg[1].toLowerCase();
				arg[3] = arg[3].toLowerCase().replace("-", "").replace("_", "");
                
				arg[1] = conformHex(arg[1], pokemontable, true);
				arg[2] = conformHex(arg[2]);
				arg[3] = conformHex(arg[3], itemstable, true);
				
				if (arg.indexOf(false) > -1) {
					success = false;
					alert("String given for givepokemon call in inappropriate place. Only item and pokemon IDs can be strings, not the level.");
					return;
				}
				
				if (arg[0].toLowerCase().includes("pokemon")) {
			
					body += "givepokemon "+arg[1]+" "+arg[2]+" "+arg[3]+" 0x0 0x0 0x0";
					
				} else {
				
					body += "wildbattle "+arg[1]+" "+arg[2]+" "+arg[3];
					
				}

                break;
			case "":
				noliNewLineAre = true;
            default:
				if (arg[0].charAt(0) == "@" && arg[0].length > 1) { //label name case
					lines.splice((i+1), 0, "@ "+arg[0]);
					continue;
				} else { //true default case
					arg = derefAllFromIndex(arg, 1);
					body += arg.join(" ");
					break;
				}
        }
		
		} else if (isFuncDef == true) {
			noliNewLineAre = true;
			//funcdef
			if (arg[0] == "$funcend") {
				isFuncDef = false;
				funcName = "";
			} else {
				if (arg[0] == "const") {
					success = false;
					alert("Consts cannot be defined in functions.");
					return;
				}
				let val = arg.slice(0).join(" ")+"\n";
				if (autosav) {
					let obj = JSON.parse(localStorage.func);
					if (typeof obj[funcName] == 'undefined') {
						obj[funcName] = "";
					}
					obj[funcName] += val;
					localStorage.func = JSON.stringify(obj);
				}
				allScripts[funcName] += val;
			}
			
		} else if (isFuncDef == "com") {
			if (arg[0].toLowerCase() == "&comend"){
				isFuncDef = oldFuncValue;
			}
			noliNewLineAre = true;
		} else if (isFuncDef == "loop") {
			let cond;
			if (noCompile) {
				cond = arg.indexOf("expend");
			} else {
				cond = Math.max(arg.indexOf("lend"), arg.indexOf("loopend"));
			}
			
			let fin = 0;
			
			if (cond > -1) {
			
				for (let j = 0; j < loopTimes; j++) {
					let nloopdat = cLoopData;
					
					let iterExpr = ((loopTimes-j-1)*(loopMult)+(loopOff)).toString();
					
					console.log(iterExpr);
					
					if (nloopdat.toLowerCase().includes("%loopiterh")) {
						nloopdat = nloopdat.replace(new RegExp("%loopiterh", "gi"), conformHex(iterExpr));
					}
					if (nloopdat.toLowerCase().includes("%loopiter")) {
						nloopdat = nloopdat.replace(new RegExp("%loopiter", "gi"), iterExpr);
					}
					if (lmode == "exp") {
						res.splice(splicePoint, 0, nloopdat.split("\n"));
						
						
						if (j == loopTimes-1) {
							//if last iter
							
							FSEeditor.setValue(res.flat().join("\n"));
							
						}
						
					} else {
						lines.splice(i+1, 0, nloopdat.split("\n"));
					}
				}
				lines = lines.flat();
				
				loopMult = 1;
				loopOff = 0;
				
				isFuncDef = false;
				cLoopData = "";
				
				loopTimes = 0;
				
			} else {
				cLoopData += arg.slice(0).join(" ")+"\n";
			}
			noliNewLineAre = true;
			
			FSEeditor.clearSelection();
		} else if (isFuncDef == "tab") {
			arg[0] = arg[0].toLowerCase();
			
			let endList = ["$tabend", "$endtable"];
			
			if (endList.indexOf(arg[0]) > -1) {
				isFuncDef = false;
			} else if (arg[0] != "") {
				constTable[arg[0].toLowerCase()+tableName.toLowerCase()] = arg.slice(1).join(" ").replace(new RegExp(" ", "g"), "&sp");
			}
			
			noliNewLineAre = true;
			
		}
        
        if (!noliNewLineAre) {
            body += "\n";
        }
        noliNewLineAre = false;

        }

    }
	
	if (isFuncDef != false && !noCompile) {
		success = false;
		alert("Compiler is not in main state. A function or loop somewhere was not closed properly.");
		return;
	}
	
	if (activeLabel) {
		success = false;
		alert("Label not closed. Use 'end' or 'ret' to close a label.");
	}
	
	if (!endCalled) {
		body += "\nend\n";
	}
	
	if (noCompile) {
		return noCompString;
	}
	
	let k = String.raw`kek`.replace("kek", body);
	
	if ({objk: k.replace(/end/g, "").replace(/\n/g, "")}.objk.length == 0) {
		
		return "nothing to compile :(";
	}

    return header1+scriptText+header2+body+"\n"+footer+"\n\n";
}










function calcProgramBytes(text) {

    var lines = (text+"\n").split(/\n/);
    var bytesToOffset = 0;

    for(var i = 0; i < lines.length; i++) {
		var cline = lines[i];
        if (cline.charAt(0) != ";") {
        var arg = cline.split(" ");

        switch(arg[0].toLowerCase()) {
            case "applymovement":
            case "movement":
            case "mvmt":
            case "move":
            case "movenowait":
            case "movenowaitmovement":
            case "moven":
            case "moveno":
            case "movewait":
            case "movewithwait":
            case "movewithawait":
            case "movewithwaitmovement":
            case "movewithawaitmovement":
                bytesToOffset += arg.length;
                break;
            case "wrp":
            case "warp":
                bytesToOffset += 6;
                break;
            case "msgbox":
            case "msg":
            case "text":
            case "txt":
            case "filltext":
            case "domsgbox":
            case "message":
            case "messagebox":
                bytesToOffset += arg.slice(1).join(" ").length;
                break;
            case "givepokemon":
            case "givepoke":
            case "gp":
            case "addpokemon":
            case "pokemongive":
            case "poke":
            case "pokemon":
                if (text.includes("autoobtain false")) {
                    bytesToOffset += arg.length;
                }
                bytesToOffset += arg.length;
                break;
            default:
                bytesToOffset += arg.length+2;
                break;
        }
        }

    }

	return bytesToOffset;

}










var goff = document.getElementById("offset").value;
var whichGame = "rse";

var inbutton = document.getElementById("in");
var outbutton = document.getElementById("out");

outbutton.style.max_width = outbutton.style.width;
outbutton.style.max_height = outbutton.style.height;

if (localStorage["inputdata"] != "undefined" && localStorage["inputdata"] != undefined && localStorage["inputdata"] != null) {
    FSEeditor.setValue(localStorage["inputdata"], 0);
}




function convert() {
	resetAll();

    var inbutton = document.getElementById("in");
    var outbutton = document.getElementById("out");

    var rse = document.getElementById("rse").selected;
    var frlg = document.getElementById("frlg").selected;

    goff = document.getElementById("offset").value;
    var stat = document.getElementById("status");

    if (rse) {
        whichGame = "rse";
    } else {
        whichGame = "frlg";
    }
	
	FSEeditor.setValue( FSEeditor.getValue().replace(new RegExp("!se", "gi"), "expstart").replace(new RegExp("!ee", "gi"), "expend").replace(new RegExp("%li", "gi"), "%loopiter") );

    var intext = FSEeditor.getValue();
    localStorage["inputdata"] = intext;

    var res = getXSE(intext);

    if (success) {
        outbutton.innerHTML = res;

        outbutton.select();
        document.execCommand("copy");
        window.getSelection().removeAllRanges();
		
		FSEeditor.focus();
        
        stat.innerHTML = "Conversion successful. Output data copied to clipboard.";
    } else {
        stat.innerHTML = "Conversion unsuccessful. An alert box should have explained the error.";
        success = true;
    }
	
	outbutton.scrollTop = 0;

}






















        </script>
    </body>
</html>
